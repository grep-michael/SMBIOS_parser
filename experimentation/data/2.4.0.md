STATUS: Final

Copyright © "2000, 2002, 2004" Distributed Management Task Force, Inc. (DMTF). All rights reserved.

DMTF is a not-for-profit association of industry members dedicated to promoting enterprise and systems management and interoperability. Members and non-members may reproduce DMTF specifications and documents for uses consistent with this purpose, provided that correct attribution is given. As DMTF specifications may be revised from time to time, the particular version and release date should always be noted.

Implementation of certain elements of this standard or proposed standard may be subject to third party patent rights, including provisional patent rights (herein "patent rights"). DMTF makes no representations to users of the standard as to the existence of such rights, and is not responsible to recognize, disclose, or identify any or all such third party patent right, owners or claimants, nor for any incomplete or inaccurate identification or disclosure of such rights, owners or claimants. DMTF shall have no liability to any party, in any manner or circumstance, under any legal theory whatsoever, for failure to recognize, disclose, or identify any such third party patent rights, or for such party's reliance on the standard or incorporation thereof in its product, protocols or testing procedures. DMTF shall have no liability to any party implementing such standard, whether such implementation is foreseeable or not, nor to any patent owner or claimant, and shall have no liability or responsibility for costs or losses incurred if a standard is withdrawn or modified after publication, and shall be indemnified and held harmless by any party implementing the standard from any and all claims of infringement by a patent owner for such implementations.

For information about patents held by third parties that have notified the DMTF that, in their opinion, such patent may relate to or impact implementations of DMTF standards, visit http://www.dmtf.org/about/policies/disclosures.php.

System Management BIOS (SMBIOS) Reference Specification

Version 2.4
July 21, 2004

Abstract

Continuing the DMTF's mission of leading the development of management standards for distributed desktop, network, enterprise and Internet environments, the System Management BIOS Reference Specification addresses how motherboard and system vendors present management information about their products in a standard format by extending the BIOS interface on Intel architecture systems. The information is intended to allow generic instrumentation to deliver this data to management applications that use DMI, CIM or direct access and eliminates the need for error prone operations like probing system hardware for presence detection.

This specification is intended to provide enough information for BIOS developers to implement the necessary extensions to allow their product's hardware and other system-related information to be accurately determined by users of the defined interfaces. This specification is also intended to provide enough information for developers of management instrumentation to develop generic routines for translating from SMBIOS format to the format used by their chosen management technology whether it is a DMTF technology like DMI or CIM, or another technology like SNMP. To support this translation for DMTF technologies, sections of this specification describe the DMI groups and CIM classes intended to convey the information retrieved from an SMBIOS-compatible system through the interfaces described in this document.
Note: The DMTF's DMI working group controls changes to this document; change requests should be submitted to mailto://wg-dmi@dmtf.org. Refer to http://www.dmtf.org/standards/bios.php for the most recent version of this document.
Document Revision History

<table>
  <tr>
    <th>Version</th>
    <th>Release Date</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>2.0D</td>
    <td>09/14/1995</td>
    <td>Initial Release of DRAFT COPY</td>
  </tr>
  <tr>
    <td>2.0M</td>
    <td>12/12/1995</td>
    <td>Final draft released, with the following changes:
      <ul>
        <li>Specified that dmiStorageBase (Function 50h) and NVStorageBase (Function 55h) must be paragraph-aligned.</li>
        <li>Added Command value to change a string to function 52h; Command enumeration values modified.</li>
        <li>Removed redundant enumerations from Processor Family list</li>
        <li>Corrected Memory Subsystem Example</li>
        <li>Corrected/clarified Indexed I/O access-methods for event-log; Access Method enumeration values and Access Method Address union modified</li>
        <li>Added clarifications to some of the event log types</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.00</td>
    <td>03/06/1996</td>
    <td>Final release, with the following changes:
      <ul>
        <li>Specified that all structures end with a terminating NULL, even if the formatted portion of the structure contains string-reference fields and all the string fields are set to 0.</li>
        <li>Corrected the Memory Subsystem Example, handles are now correctly created with a 'dw'.</li>
        <li>Fixed formatting of some bit definition fields and function examples.</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.00.1</td>
    <td>07/18/1996</td>
    <td>Minor updates for new technology and clarifications.
      <ul>
        <li>Added definitions for Pentium® Pro, Burst EDO, and SDRAM.</li>
        <li>Added clarifications to the Memory Controller Error Status.</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>06/16/1997</td>
    <td>Added definition for static table interface, to allow the information to be accessed from new operating systems, see 2.1 Table Convention on page 13. In addition:
      <ul>
        <li>Changed references to DMI BIOS to SMBIOS throughout; these changes are unmarked.</li>
        <li>Added SubFunction DMI CLEAR_EVENT LOG2 to Function 54h - SMBIOS Control.</li>
        <li>For those structure entries that are string numbers, changed the Value field definition of the field from Varies to STRING throughout; these changes are unmarked.</li>
        <li>BIOS Information structure: Added support for 4-digit year and additional BIOS Characteristics via Characteristics Extension Byte 1.</li>
        <li>System Information structure: Added Wakeup Type and UUID fields.</li>
        <li>System Enclosure and Chassis structure: Added Bootup State, Power Supply State, Thermal State, and Security Status to allow the DMTF Physical Container Global Table to be populated.</li>
        <li>Processor Information structure: Voltage value can now be specified, rather than using bit-flags, and added enumeration values for Pentium® Pro, Pentium® II, and Slot 1. Also added notes to this section, indicating that the enumerated values for the structure are assigned by the DMTF. This structure was also updated to include the Cache Information handles identifying the L1, L2, and L3 caches associated with the processor.</li>
        <li>Memory Controller Information structure: Added Enabled Error Correcting field. Also added note that this structure can never be updated to add string values, to preserve backwards compatibility.</li>
        <li>Cache Information structure: Added Speed, Error Correction Type, Type, and Associativity fields.</li>
        <li>Port Connector Information structure: Added enumerated values to Connector Types and Port Types.</li>
        <li>System Slots structure: Added AGP enumeration values to Slot Type field.</li>
        <li>BIOS Language Information structure: Added abbreviated-format for language strings and corrected example.</li>
        <li>System Event Log structure: OEM-specific Access Methods can now be defined, added standard log header definitions, and a mechanism to allow the log entry's variable data formats to be described. Added note that this structure can never be updated to include string values, to preserve backwards compatibility.</li>
        <li>Added Physical Memory Array, Memory Device, Memory Error Information, Memory Array Mapped Address, and Memory Device Mapped Address structures to support the population of the DMTF Enhanced Physical Memory groups.</li>
        <li>Added Built-in Pointing Device structure to support the population of the DMTF Pointing Device group.</li>
        <li>Added Portable Battery structure to support the population of the DMTF Portable Battery group.</li>
        <li>Added appendices that contain a structure checklist and table-convention parsing pseudo-code.</li>
      </ul>
    </td>
  </tr>
</table>
<table>
  <tr>
    <th>Version</th>
    <th>Release Date</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>2.2</td>
    <td>03/16/1998</td>
    <td>The following changes were made to v2.1 of the document to produce this version:
      <ul>
        <li>Accepted all changes introduced at Version 2.1</li>
        <li>Added ACPI statement-of-direction for dynamic state and event notification</li>
        <li><i>Table-convention is required for v2.2 and later compliance</i></li>
        <li>Corrected Structure Table entry point length value.</li>
        <li>Added Command type 06h to the Plug-and-Play Set SMBIOS Structure function (52h).</li>
        <li>Added new processor enumerations from the updated DMTF MASTER.MIF</li>
        <li>System Enclosure: Added enumeration value for "Sealed-case PC", to support Net PC-type chassis'.</li>
        <li>Memory Controller Information: Corrected description of how the BIOS computes the structure Length.</li>
        <li>System Event Log:
          <ul>
            <li>Added definition for end-of-log data, Event Log Type 0FFh.</li>
            <li>Added generic system-management event type; the handle of an associated probe or cooling device identifies the specific failing device.</li>
          </ul>
        </li>
        <li>Memory Error Information: Corrected structure size and offsets.</li>
        <li>Portable Battery: Corrected the structure length and some of the offsets, added Smart Battery-formatted fields</li>
        <li>Memory Device: Added RIMM form factor</li>
        <li>Added the following new structures
          <ul>
            <li>System Reset structure to support the population of the DMTF Automatic System Reset group.</li>
            <li>Hardware Security structure to support the population of the DMTF System Hardware Security group.</li>
            <li>System Power Control structure to support the population of the DMTF System Power Control group.</li>
            <li>Added Voltage Probe structure to support the population of the DMTF Voltage Probe group.</li>
            <li>Cooling Device structure to support the population of the DMTF Cooling Device group.</li>
            <li>Temperature Probe structure to support the population of the DMTF Temperature Probe group.</li>
            <li>Electrical Current Probe structure to support the population of the DMTF Electrical Current Probe group.</li>
            <li>Out-of-Band Remote Access structure to support the population of the DMTF Out-of-Band Remote Access group.</li>
            <li>Inactive structure type to support standard structure superset definitions.</li>
            <li>End-of-Table structure type to facilitate easier traversing of the structure data.</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
</table>
<table>
  <tr>
    <th>Version</th>
    <th>Release Date</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>2.3</td>
    <td>08/12/1998</td>
    <td>The following changes were made to v2.2 of the document to produce this version:
      <ul>
        <li>Accepted all changes introduced at Version 2.2</li>
        <li>Clarified and corrected referenced documents</li>
        <li>A minimum set of structures (and their data) is now required for SMBIOS compliance.</li>
        <li>Documented an additional structure usage guideline, to optional structure growth.</li>
        <li>BIOS Information:
          <ul>
            <li>4-digit year format for BIOS Release Date required for SMBIOS 2.3 and later</li>
            <li>Added BIOS Characteristic Extension Byte 2 to include status that the BIOS supports the <i>BIOS Boot Specification</i>.</li>
          </ul>
        </li>
        <li>System Information: Added enumeration for Wake-up Type</li>
        <li>System Enclosure or Chassis: Added OEM-defined field.</li>
        <li>Processor Information:
          <ul>
            <li>Added enumerated values for new processors from the updated MASTER.MIF and identified that one structure is present for each processor instance.</li>
            <li>Modified interpretation of Lx Cache Handle fields for v2.3 and later implementations</li>
          </ul>
        </li>
        <li>Memory Module Information: Corrected example, adding double-null to terminate the structure.</li>
        <li>System Slots: Added hot-plug characteristic definition and clarified usage of the PCI “Slot ID” field.</li>
        <li>Memory Device:
          <ul>
            <li>Added enumerations for Form Factor and Device Type</li>
            <li>Added new field for memory Speed</li>
          </ul>
        </li>
        <li>System Event Log: Added note describing how century portion of the 2-digit year within a log record is to be interpreted.</li>
        <li>Voltage Probe, Temperature Probe, Electrical Current Probe, Cooling Device:
          <ul>
            <li>Added Nominal Value field</li>
          </ul>
        </li>
        <li>Added the following new structures
          <ul>
            <li>Boot Integrity Services (BIS) Entry Point</li>
            <li>System Boot Information</li>
            <li>64-bit Memory Error Information</li>
            <li>Management Device</li>
            <li>Management Device Component</li>
            <li>Management Device Threshold Data</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.3.1</td>
    <td>3/16/1999</td>
    <td>The following changes were made to v2.3 of the document to produce this version:
      <ul>
        <li>Accepted all changes introduced at Version 2.3</li>
        <li>Adopted a three-tier document numbering procedure, see 1.1 for more information.</li>
        <li>BIOS Information:
          <ul>
            <li>Added BIOS Characteristic Extension Byte 2, bit 1, to identify that the BIOS supports F12=Network Boot functionality</li>
          </ul>
        </li>
        <li>Processor Information
          <ul>
            <li>Added Processor Family enumeration for new Pentium processors, defined reserved values for future Pentium processors.</li>
            <li>Added fields: Asset Tag, Serial Number, and Part Number.</li>
          </ul>
        </li>
        <li>System Slots
          <ul>
            <li>Added slot type enumeration for PCI-X</li>
            <li>Added slot characteristic to identify support for (to-be) standard SMBus interface for PCI slots</li>
          </ul>
        </li>
        <li>Memory Device:
          <ul>
            <li>Added enumerated values for Memory Type and Form Factor, required for RamBus implementations</li>
            <li>Added fields: Manufacturer, Asset Tag, Serial Number, and Part Number.</li>
          </ul>
        </li>
        <li>Added the following new structures:
          <ul>
            <li>Memory Channel (to support RamBus and SyncLink memory implementations)</li>
            <li>IPMI Device, to abstract the IPMI hardware dependencies to management software</li>
            <li>System Power Supply</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.3.1</td>
    <td>12/14/2000</td>
    <td>Released as DMTF Preliminary Specification DSP0119.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Version</th>
    <th>Release Date</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>2.3.2</td>
    <td>12 October 2001</td>
    <td>The following changes were made to v2.3.1 of the document to produce this version:
      <ul>
        <li>Accepted all changes introduced at v2.3.1</li>
        <li>Released as DMTF Specification DSP0130 (Preliminary)</li>
        <li>Updated the Abstract and Overview sections to be more DMTF-general than DMI-specific. Change bars are present in the Overview section only.</li>
        <li>Deleted section 1.1 (future direction for ACPI interface specification). Any ACPI interface to provide these structures should be provided by a future version of the ACPI specification itself.</li>
        <li>Removed "References" that had broken links.</li>
        <li>Modified sections 2 and 2.2 to indicate that the PnP calling interface is being deprecated at this specification version.</li>
        <li>Noted in section 2.1 that the structure table data is boot-time static.</li>
        <li>For each enumerated list that indicated that the enumeration is controlled by the "DMTF, not this specification", identified which CIM class, property and DMI group, attribute are mapped to the enumerated value. Also added a note in the Overview section to indicate where change requests should be sent.</li>
        <li>Baseboard Information (Type 2)
          <ul>
            <li>Added fields: Asset Tag, Feature Flags, Location in Chassis, Chassis Handle, Baseboard Type, and Contained Objects to support multi-system chassis like server blades.</li>
          </ul>
        </li>
        <li>System Enclosure or Chassis (Type 3)
          <ul>
            <li>Added fields: Height, Number of Power Cords, Contained Element Count, and Contained Elements to support multi-system chassis like server blades.</li>
          </ul>
        </li>
        <li>Processor Information (Type 4)
          <ul>
            <li>Added new enumerations to Processor Family and Processor Upgrade</li>
            <li>Removed (SMBIOS-only) reserved ranges. These ranges are controlled by the DMTF, not the SMBIOS group. The DMTF Device MOF (starting with v2.3) has commentary around the Processor Family enumeration that suggests that enumerations below 256 be used only for those processor types that are going to be reported via SMBIOS (since this specification's Processor Family field is a 1-byte entity).</li>
            <li>Cache (Type 7)
              <ul>
                <li>Added new enumerations to Associativity</li>
              </ul>
            </li>
            <li>Memory Device (Type 17)
              <ul>
                <li>Added new enumerations to Memory Type</li>
              </ul>
            </li>
            <li>Built-in Pointing Device (Type 21)
              <ul>
                <li>Added new enumerations to Pointing Device Type</li>
              </ul>
            </li>
            <li>Removed out-of-date section Correlation to DMTF Groups, in favor of updated section 3.3.</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.3.3</td>
    <td>10 May 2002</td>
    <td>The following changes were made to v2.3.2 of the document to produce this version:
      <ul>
        <li>Accepted all changes introduced at v2.3.2</li>
        <li>Updated the Abstract to contain the updated DMTF copyright statement.</li>
        <li>Processor Information (Type 4)
          <ul>
            <li>Added new enumerations to Processor Family and Processor Upgrade</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>2.3.4</td>
    <td>06 December 2002</td>
    <td>The following changes were made to v2.3.3 of the document to produce this version:
      <ul>
        <li>System Enclosure Information (Type 3)
          <ul>
            <li>Provided clarification regarding contained element types</li>
          </ul>
        </li>
        <li>Processor Information (Type 4)
          <ul>
            <li>Added and corrected enumerations to Processor Family (CR00002)</li>
            <li>Provided clarification for Max Speed and Current Speed.</li>
            <li>Additions to Processor Upgrade (CR00002)</li>
          </ul>
        </li>
        <li>System Slots (Type 9)
          <ul>
            <li>Added AGP8X enumeration to Slot Type</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
</table>
<table>
  <tr>
    <th>Version</th>
    <th>Release Date</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>2.4</td>
    <td>21 July 2004</td>
    <td>The following changes were made to v2.3.4 of the document to produce this version:
      <ul>
        <li>Processor Information (Type 4)
          <ul>
            <li>Added new enumerations to Processor Family (CR00951, CR01152)</li>
          </ul>
        </li>
        <li>System Slots (Type 9)
          <ul>
            <li>Added PCI Express enumeration to Slot Type (CR01259)</li>
            <li>Added new enumerations to Slot Data Bus Width (CR01324)</li>
          </ul>
        </li>
        <li>Memory Device (Type 17)
          <ul>
            <li>Added DDR2 enumeration to Type (CR01263)</li>
          </ul>
        </li>
        <li>BIOS Information (Type 0)
          <ul>
            <li>Added fields: System BIOS Major Release, System BIOS Minor Release, Embedded Controller Firmware Major Release, and Embedded Controller Firmware Minor Release (CR01270)</li>
            <li>Added BIOS Characteristic Extension Byte 2, bit 2, to identify that the BIOS supports Targeted Content Distribution (CR01270)</li>
          </ul>
        </li>
        <li>System Information (Type 1)
          <ul>
            <li>Added fields: SKU Number and Family (CR01270)</li>
          </ul>
        </li>
        <li>Updated Conformance Guidelines and added corrections.</li>
      </ul>
    </td>
  </tr>
</table>
Table Of Contents

1.1 DOCUMENT VERSION NUMBER CONVENTIONS 11
1.2 REFERENCES 12
1.3 CONVENTIONS USED IN THIS DOCUMENT 12

2. ACCESSING SMBIOS INFORMATION 12

2.1 TABLE CONVENTION 13
  2.1.1 SMBIOS STRUCTURE TABLE ENTRY POINT 13
2.2 PLUG-AND-PLAY CALLING CONVENTION 14
  2.2.1 SMBIOS FUNCTIONS 15
  2.2.2 ERROR RETURN CODES 15
  2.2.3 SMBIOS STRUCTURE ACCESS INTERFACE 16
    2.2.3.1 Function 50h – Get SMBIOS Information 16
    2.2.3.2 Function 51h – Get SMBIOS Structure 17
    2.2.3.3 Function 52h – Set SMBIOS Structure 18
  2.2.4 STRUCTURE CHANGE NOTIFICATION INTERFACE 21
    2.2.4.1 Function 53h – Get Structure Change Information 21
  2.2.5 CONTROL INTERFACE 23
    2.2.5.1 Function 54h – SMBIOS Control 23
  2.2.6 GENERAL PURPOSE NONVOLATILE STORAGE INTERFACE 25
    2.2.6.1 Function 55H – Get General-Purpose NonVolatile Information 25
    2.2.6.2 Function 56H – Read General-Purpose NonVolatile Data 26
    2.2.6.3 Function 57H – Write General-Purpose NonVolatile Data 27

3. SMBIOS STRUCTURES 29

3.1 STRUCTURE STANDARDS 29
  3.1.1 STRUCTURE EVOLUTION AND USAGE GUIDELINES 29
  3.1.2 STRUCTURE HEADER FORMAT 30
  3.1.3 TEXT STRINGS 30
3.2 REQUIRED STRUCTURES AND DATA 31
3.3 STRUCTURE DEFINITIONS 32
  3.3.1 BIOS INFORMATION (TYPE 0) 34
    3.3.1.1 BIOS Characteristics 35
    3.3.1.2 BIOS Characteristics Extension Bytes 35
  3.3.2 SYSTEM INFORMATION (TYPE 1) 36
    3.3.2.1 System — Wake-up Type 37
  3.3.3 BASE BOARD (OR MODULE) INFORMATION (TYPE 2) 37
    3.3.3.1 Base Board — Feature Flags 38
    3.3.3.2 Base Board — Board Type 38
  3.3.4 SYSTEM ENCLOSURE OR CHASSIS (TYPE 3) 39
    3.3.4.1 System Enclosure or Chassis Types 40
    3.3.4.2 System Enclosure or Chassis States 40
    3.3.4.3 System Enclosure or Chassis Security Status 41
    3.3.4.4 System Enclosure or Chassis: Contained Elements 41
  3.3.5 PROCESSOR INFORMATION (TYPE 4) 42
    3.3.5.1 Processor Information - Processor Type 43
    3.3.5.2 Processor Information - Processor Family 44
    3.3.5.3 Processor ID Field Format 46
    3.3.5.4 Processor Information – Voltage 46
    3.3.5.5 Processor Information - Processor Upgrade 46
3.3.6 MEMORY CONTROLLER INFORMATION (TYPE 5) 47
    3.3.6.1 Memory Controller Error Detecting Method 48
    3.3.6.2 Memory Controller Error Correcting Capability 48
    3.3.6.3 Memory Controller Information - Interleave Support 48
    3.3.6.4 Memory Controller Information - Memory Speeds 49
3.3.7 MEMORY MODULE INFORMATION (TYPE 6) 49
    3.3.7.1 Memory Module Information - Memory Types 50
    3.3.7.2 Memory Module Information - Memory Size 50
    3.3.7.3 Memory Subsystem Example 50
3.3.8 CACHE INFORMATION (TYPE 7) 52
    3.3.8.1 Cache Information - SRAM Type 52
    3.3.8.2 Cache Information — Error Correction Type 53
    3.3.8.3 Cache Information — System Cache Type 53
    3.3.8.4 Cache Information — Associativity 53
3.3.9 PORT CONNECTOR INFORMATION (TYPE 8) 53
    3.3.9.1 Port Information Example 54
    3.3.9.2 Port Information - Connector Types 54
    3.3.9.3 Port Types 55
3.3.10 SYSTEM SLOTS (TYPE 9) 56
    3.3.10.1 System Slots - Slot Type 56
    3.3.10.2 System Slots - Slot Data Bus Width 57
    3.3.10.3 System Slots - Current Usage 57
    3.3.10.4 System Slots - Slot Length 57
    3.3.10.5 System Slots — Slot ID 57
    3.3.10.6 Slot Characteristics 1 58
    3.3.10.7 Slot Characteristics 2 58
3.3.11 ON BOARD DEVICES INFORMATION (TYPE 10) 58
    3.3.11.1 Onboard Device Types 59
3.3.12 OEM STRINGS (TYPE 11) 59
3.3.13 SYSTEM CONFIGURATION OPTIONS (TYPE 12) 59
3.3.14 BIOS LANGUAGE INFORMATION (TYPE 13) 59
3.3.15 GROUP ASSOCIATIONS (TYPE 14) 60
3.3.16 SYSTEM EVENT LOG (TYPE 15) 61
    3.3.16.1 Supported Event Log Type Descriptors 64
    3.3.16.2 Indexed I/O Access Method 64
    3.3.16.3 Access Method Address — DWORD Layout 65
    3.3.16.4 Event Log Organization 65
    3.3.16.5 Log Header Format 65
    3.3.16.6 Log Record Format 67
3.3.17 PHYSICAL MEMORY ARRAY (TYPE 16) 70
    3.3.17.1 Memory Array — Location 71
    3.3.17.2 Memory Array — Use 71
    3.3.17.3 Memory Array — Error Correction Types 71
3.3.18 MEMORY DEVICE (TYPE 17) 72
    3.3.18.1 Memory Device — Form Factor 73
    3.3.18.2 Memory Device — Type 73
    3.3.18.3 Memory Device — Type Detail 74
3.3.19 32-BIT MEMORY ERROR INFORMATION (TYPE 18) 74
    3.3.19.1 Memory Error — Error Type 75
    3.3.19.2 Memory Error — Error Granularity 75
    3.3.19.3 Memory Error — Error Operation 75
3.3.20 MEMORY ARRAY MAPPED ADDRESS (TYPE 19) 76
3.3.21 MEMORY DEVICE MAPPED ADDRESS (TYPE 20) 76
3.3.22 BUILT-IN POINTING DEVICE (TYPE 21) 77
    3.3.22.1 Pointing Device — Type 77
    3.3.22.2 Pointing Device — Interface 78
3.3.23 PORTABLE BATTERY (TYPE 22) 78
    3.3.23.1 Portable Battery — Device Chemistry 79
3.3.24 SYSTEM RESET (TYPE 23) 80
3.3.25 HARDWARE SECURITY (TYPE 24) 80
3.3.26 SYSTEM POWER CONTROLS (TYPE 25) 81
    3.3.26.1 System Power Controls — Calculating the Next Scheduled Power-on Time 81
3.3.27 VOLTAGE PROBE (TYPE 26) 82
    3.3.27.1 Voltage Probe — Location and Status 82
3.3.28 COOLING DEVICE (TYPE 27) 83
    3.3.28.1 Cooling Device — Device Type and Status 83
3.3.29 TEMPERATURE PROBE (TYPE 28) 84
    3.3.29.1 Temperature Probe — Location and Status 84
3.3.30 ELECTRICAL CURRENT PROBE (TYPE 29) 85
    3.3.30.1 Current Probe — Location and Status 85
3.3.31 OUT-OF-BAND REMOTE ACCESS (TYPE 30) 86
3.3.32 BOOT INTEGRITY SERVICES (BIS) ENTRY POINT (TYPE 31) 86
3.3.33 SYSTEM BOOT INFORMATION (TYPE 32) 87
    3.3.33.1 System Boot Status 87
3.3.34 64-BIT MEMORY ERROR INFORMATION (TYPE 33) 87
3.3.35 MANAGEMENT DEVICE (TYPE 34) 88
    3.3.35.1 Management Device — Type 88
    3.3.35.2 Management Device — Address Type 89
3.3.36 MANAGEMENT DEVICE COMPONENT (TYPE 35) 89
3.3.37 MANAGEMENT DEVICE THRESHOLD DATA (TYPE 36) 89
3.3.38 MEMORY CHANNEL (TYPE 37) 90
    3.3.38.1 Memory Channel — Channel Type 90
3.3.39 IPMI DEVICE INFORMATION (TYPE 38) 91
    3.3.39.1 IPMI Device Information — BMC Interface Type 91
3.3.40 SYSTEM POWER SUPPLY (TYPE 39) 91
    3.3.40.1 Power Supply Characteristics 92
3.3.41 INACTIVE (TYPE 126) 93
3.3.42 END-OF-TABLE (TYPE 127) 93

4. CONFORMANCE GUIDELINES 94

5. USING THE TABLE CONVENTION 97
Overview

Continuing the DMTF’s mission of leading the development of management standards for distributed desktop, network, enterprise and Internet environments, the System Management BIOS Reference Specification addresses how motherboard and system vendors present management information about their products in a standard format by extending the BIOS interface on Intel architecture systems. The information is intended to allow generic instrumentation to deliver this data to management applications that use DMI, CIM or direct access and eliminates the need for error prone operations like probing system hardware for presence detection.

This specification is intended to provide enough information for BIOS developers to implement the necessary extensions to allow their product’s hardware and other system-related information to be accurately determined by users of the defined interfaces.

This specification is also intended to provide enough information for developers of management instrumentation to develop generic routines for translating from SMBIOS format to the format used by their chosen management technology whether it is a DMTF technology like DMI or CIM, or another technology like SNMP. To support this translation for DMTF technologies, sections of this specification describe the DMI groups and CIM classes intended to convey the information retrieved from an SMBIOS-compatible system through the interfaces described in this document.

Note: The DMTF’s DMI working group controls changes to this document; change requests should be submitted to mailto://wg-dmi@dmtf.org. Refer to http://www.dmtf.org/standards/bios.php for the most recent version of this document.

1.1 Document Version Number Conventions

Beginning with version 2.3.1 of this document, the document’s version number will be specified in a major.minor[.docrev] format. The addition of the docrev enables document updates to keep current with hardware technology without causing implementations to continually “chase” a specification version.

1. The major value of the document version increments by one (1) whenever a major interface change is introduced. Looking back, the value should have been incremented in the v2.0 to v2.1 transition since the table-based method was a major interface change. This value is also the major version of the SMBIOS specification.

2. The minor value of the document version either resets to zero (0) if the major value increments, or increments by one (1) if a change in implementation requirements is introduced within the same major version, e.g. the addition of a new required structure or structure field. This value is also the minor version of the SMBIOS specification.

3. The docrev value of the document version either resets to zero (0) if either the major or minor value increments, or increments by one (1) each time this document is updated. This value does not factor into the specification version; an implementation based on document version 2.3 complies with specification v2.3, as does an implementation based on document version 2.3.11.

4. A docrev value of 0 displays as blank, i.e. 2.4 instead of 2.4.0.

If these conventions were in place at v2.0 of the specification, here’s how they would have been applied to specification versions 2.1 through 2.3:

<table>
  <tr>
    <th>Specification Version</th>
    <th>Would have been</th>
    <th>Because …</th>
  </tr>
  <tr>
    <td>…</td>
    <td>…</td>
    <td></td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>3.0</td>
    <td>… the addition of the table-based method constitutes a major interface change.</td>
  </tr>
  <tr>
    <td>2.2</td>
    <td>3.1</td>
    <td>… the table-based method was made a requirement for compliance.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Specification Version ...</th>
    <th>Would have been ...</th>
    <th>Because ...</th>
  </tr>
  <tr>
    <td>2.3</td>
    <td>3.2</td>
    <td>... a minimum set of structures was made a requirement for compliance.</td>
  </tr>
</table>

1.2 References

• Advanced Configuration and Power Interface Specification, Version 1.0, December 23 1996, http://www.teleport.com/~acpi
• BIOS Boot Specification, Version 1.01, 11 January 1996, http://www.phoenix.com/techs/specs.html
• Boot Integrity Services API, Version 1.00, 26 October 1999, http://developer.intel.com/ial/WfM/tools/BIS/Index.htm
• Desktop Management Interface Specification, Version 2.0s, 24 June 1998, http://www.dmtf.org/standards/standard_dmi.php
• DMTF MASTER.MIF, http://www.dmtf.org/standards/standard_dmi.php
• DMTF DMI 2.0 Conformance Requirements Version 1.1, 10 December 1997, http://www.dmtf.org/standards/standard_dmi.php
• “El Torito” Bootable CD-ROM Format Specification, Version 1.0, January 25 1995, http://www.phoenix.com/techs/specs.html
• Intelligent Platform Management Interface (IPMI) Interface Specification, Version 1.0, September 16, 1998, http://developer.intel.com/design/servers/ipmi/spec.htm
• PCI IRQ Routing Table Specification, Version 1.0, 27 February 1996, http://www.microsoft.com/hwdev/busbios/PCIIRQ.HTM
• Plug and Play BIOS Specification, Version 1.0A, May 5, 1994, ftp://ftp.microsoft.com/develop/dr/Plug-and-Play/Pnpspecs/pnpbios.exe
• Simple Boot Flag Specification, Version 1.0, 06 April, 1998, http://www.microsoft.com/hwdev/desinit/simp_bios.htm
• Smart Battery Data Specification, Version 1.0, 15 February 1995, www.sbs-forum.org

1.3 Conventions Used in this Document

1. All numbers specified in this document are in decimal format unless otherwise indicated. A number followed by the letter ‘h’ indicates hexadecimal format; a number followed by the letter ‘b’ indicates binary format.

For example, the values 10, 0Ah, and 1010b are equivalent.

2. Any value not listed in an enumerated list is reserved for future assignment by the DMTF, see section 3 for more information.

3. Most of the enumerated values defined in this specification simply track the like values specified by the DMTF — either within the DMTF’s MASTER.MIF or CIM classes. Enumerated values that are controlled by the DMTF are identified within their respective subsection; additional values for these fields are assigned by the DMTF, see section 3.3 for more information.

2. Accessing SMBIOS Information

There are two access methods defined for the SMBIOS structures:

1. The first method, defined in v2.0 of this specification, provides the SMBIOS structures through a Plug-and-Play function interface, see 2.2 Plug-and-Play Calling Convention on page 14.

2. A table-based method, defined in v2.1 of this specification, provides the SMBIOS structures as a packed list of data referenced by a table entry point; see 2.1 Table Convention on page 13.
A BIOS compliant with v2.1 of this specification can provide one or both methods. A BIOS compliant with v2.2 and later of this specification must provide the table-based method and can optionally provide the Plug-and-Play function interface.

Important Note: As of version 2.3.2 of this specification, the Plug-and-Play function interface described in this section is being deprecated. Further use of the interface is discouraged and it will ultimately be removed from this specification. Future SMBIOS implementations and SMBIOS data consumers should migrate to using the table-based method described in Section 2.1 exclusively.

2.1 Table Convention

The table convention allows the SMBIOS structures to be accessed under 32-bit protected-mode operating systems such as Microsoft Windows NT*. This convention provides a searchable entry-point structure that contains a pointer to the packed SMBIOS structures residing somewhere in 32-bit physical address space.

Note 1: The table convention is required for SMBIOS v2.2 and later implementations.

Note 2: The information present in the table-based structures is boot-time static, and SMBIOS consumers should not expect the information to be updated during normal system operations.

2.1.1 SMBIOS Structure Table Entry Point

The SMBIOS Entry Point structure, described below, can be located by application software by searching for the anchor-string on paragraph (16-byte) boundaries within the physical memory address range 000F0000h to 000FFFFFh. This entry point encapsulates an intermediate anchor string that is used by some existing DMI browsers.

Note: While the SMBIOS Major and Minor Versions (offsets 06h and 07h) currently duplicate the information present in the SMBIOS BCD Revision (offset 1Dh), they provide a path for future growth in this specification. The BCD Revision, for example, provides only a single digit for each of the major and minor version numbers.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Anchor String</td>
    <td>4 BYTES</td>
    <td>SM_, specified as four ASCII characters (5F 53 4D 5F).</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Entry Point Structure Checksum</td>
    <td>BYTE</td>
    <td>Checksum of the Entry Point Structure (EPS). This value, when added to all other bytes in the EPS, will result in the value 00h (using 8-bit addition calculations). Values in the EPS are summed starting at offset 00h, for Entry Point Length bytes.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Entry Point Length</td>
    <td>BYTE</td>
    <td>Length of the Entry Point Structure, starting with the Anchor String field, in bytes, currently 1Fh.<br><br>Note: This value was incorrectly stated in v2.1 of this specification as 1Eh. Because of this, there might be v2.1 implementations that use either the 1Eh or 1Fh value, but v2.2 or later implementations must use the 1Fh value.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>SMBIOS Major Version</td>
    <td>BYTE</td>
    <td>Identifies the major version of this specification implemented in the table structures, e.g. the value will be 0Ah for revision 10.22 and 02h for revision 2.1.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>SMBIOS Minor Version</td>
    <td>BYTE</td>
    <td>Identifies the minor version of this specification implemented in the table structures, e.g. the value will be 16h for revision 10.22 and 01h for revision 2.1.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Maximum Structure Size</td>
    <td>WORD</td>
    <td>Size of the largest SMBIOS structure, in bytes, and encompasses the structure's formatted area and text strings. This is the value returned as StructureSize from the Plug-and-Play Get SMBIOS Information function.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Entry Point Revision</td>
    <td>BYTE</td>
    <td>Identifies the EPS revision implemented in this structure and identifies the formatting of offsets 0Bh to 0Fh, one of:<br>00h Entry Point is based on SMBIOS 2.1 definition; formatted area is reserved and set to all 00h.<br>01h-FFh Reserved for assignment via this specification</td>
  </tr>
  <tr>
    <td>0Bh - 0Fh</td>
    <td>Formatted Area</td>
    <td>5 BYTES</td>
    <td>The value present in the Entry Point Revision field defines the interpretation to be placed upon these 5 bytes.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>Intermediate anchor string</td>
    <td>5 BYTES</td>
    <td>DMI_, specified as five ASCII characters (5F 44 4D 49 5F).<br>Note: This field is paragraph-aligned, to allow legacy DMI browsers to find this entry point within the SMBIOS Entry Point Structure.</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>Intermediate Checksum</td>
    <td>BYTE</td>
    <td>Checksum of Intermediate Entry Point Structure (IEPS). This value, when added to all other bytes in the IEPS, will result in the value 00h (using 8-bit addition calculations). Values in the IEPS are summed starting at offset 10h, for 0Fh bytes.</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>Structure Table Length</td>
    <td>WORD</td>
    <td>Total length of SMBIOS Structure Table, pointed to by the Structure Table Address, in bytes.</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>Structure Table Address</td>
    <td>DWORD</td>
    <td>The 32-bit physical starting address of the read-only SMBIOS Structure Table, that can start at any 32-bit address. This area contains all of the SMBIOS structures fully packed together. These structures can then be parsed to produce exactly the same format as that returned from a Get SMBIOS Structure function call.</td>
  </tr>
  <tr>
    <td>1Ch</td>
    <td>Number of SMBIOS Structures</td>
    <td>WORD</td>
    <td>Total number of structures present in the SMBIOS Structure Table. This is the value returned as NumStructures from the Get SMBIOS Information function.</td>
  </tr>
  <tr>
    <td>1Eh</td>
    <td>SMBIOS BCD Revision</td>
    <td>BYTE</td>
    <td>Indicates compliance with a revision of this specification. It is a BCD value where the upper nibble indicates the major version and the lower nibble the minor version. For revision 2.1, the returned value is 21h. If the value is 00h, only the Major and Minor Versions in offsets 6 and 7 of the Entry Point Structure provide the version information.</td>
  </tr>
</table>

2.2 Plug-and-Play Calling Convention

Important Note: As of version 2.3.2 of this specification, the Plug-and-Play function interface described in this section is being deprecated. Further use of the interface is discouraged and it will ultimately be removed from this specification. Future SMBIOS implementations and SMBIOS data consumers should migrate to using the table-based method described in Section 2.1 exclusively.

To prevent the proliferation of interfaces for accessing information embedded in the System BIOS, the System Management BIOS Reference Specification will follow the System Device Node model used by Plug and Play, and use Plug and Play BIOS functions to access DMI information. Plug and Play functions 50h-5Fh have been assigned to the SMBIOS BIOS Interface.

Each of the SMBIOS BIOS Plug-and-Play functions is available both in real-mode and 16-bit protected-mode. A function called in 16-bit protected-mode supports both 16-bit and 32-bit stack segments.
2.2.1 SMBIOS Functions

This table defines the current SMBIOS Functions.

<table>
  <tr>
    <th>SMBIOS Function</th>
    <th>Function Number</th>
    <th>Description</th>
    <th>Required/Optional</th>
  </tr>
  <tr>
    <td>GET_DMI_INFORMATION</td>
    <td>50h</td>
    <td>Returns the Number of Structures, the Size of the Largest Structure, and the SMBIOS Revision.</td>
    <td>Required for calling interface</td>
  </tr>
  <tr>
    <td>GET_DMI_STRUCTURE</td>
    <td>51h</td>
    <td>Copies the information for the specified Structure into the buffer specified by the caller.</td>
    <td>Required for calling interface</td>
  </tr>
  <tr>
    <td>SET_DMI_STRUCTURE</td>
    <td>52h</td>
    <td>Copies the information for the specified SMBIOS structure from the buffer specified by the caller.</td>
    <td>Optional</td>
  </tr>
  <tr>
    <td>GET_DMI_STRUCTURE_CHANGE_INFO</td>
    <td>53h</td>
    <td>Returns the SMBIOS Structure Change Information into a 16-byte buffer specified by the caller.</td>
    <td>Required for Dynamic Structure-change Notification Support</td>
  </tr>
  <tr>
    <td>DMI_CONTROL</td>
    <td>54h</td>
    <td>Controls a system action</td>
    <td>Optional</td>
  </tr>
  <tr>
    <td>GET_GPNV_INFORMATION</td>
    <td>55h</td>
    <td>Returns information about the General Purpose Non-Volatile Storage Area</td>
    <td>Required for GPNV Support</td>
  </tr>
  <tr>
    <td>READ_GPNV_DATA</td>
    <td>56h</td>
    <td>Reads the entire specified GPNV contents into a buffer specified by the caller.</td>
    <td>Required for GPNV Support</td>
  </tr>
  <tr>
    <td>WRITE_GPNV_DATA</td>
    <td>57h</td>
    <td>Copies the contents of the user specified buffer into the GPNV. The function causes the entire specified GPNV to be updated.</td>
    <td>Required for GPNV Support</td>
  </tr>
  <tr>
    <td>Reserved for Future Use</td>
    <td>58h-5Fh</td>
    <td>Reserved, will return DMI_FUNCTION_NOT_SUPPORTED.</td>
    <td>Reserved</td>
  </tr>
</table>

2.2.2 Error Return Codes

After the call has been made, the following return codes are available in the AX Register.

<table>
  <tr>
    <th>Return Code</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>DMI_SUCCESS</td>
    <td>00h</td>
    <td>Function Completed Successfully</td>
  </tr>
  <tr>
    <td>DMI_UNKNOWN_FUNCTION</td>
    <td>81h</td>
    <td>Unknown, or invalid, function number passed</td>
  </tr>
  <tr>
    <td>DMI_FUNCTION_NOT_SUPPORTED</td>
    <td>82h</td>
    <td>The function is not supported on this system</td>
  </tr>
  <tr>
    <td>DMI_INVALID_HANDLE</td>
    <td>83h</td>
    <td>SMBIOS Structure number/handle passed is invalid or out of range.</td>
  </tr>
  <tr>
    <td>DMI_BAD_PARAMETER</td>
    <td>84h</td>
    <td>The function detected invalid parameter or, in the case of a "Set SMBIOS Structure" request, detected an invalid value for a to-be-changed structure field.</td>
  </tr>
  <tr>
    <td>DMI_INVALID_SUBFUNCTION</td>
    <td>85h</td>
    <td>The SubFunction parameter supplied on a SMBIOS Control function is not supported by the system BIOS.</td>
  </tr>
  <tr>
    <td>DMI_NO_CHANGE</td>
    <td>86h</td>
    <td>There are no changed SMBIOS structures pending notification.</td>
  </tr>
  <tr>
    <td>DMI_ADD_STRUCTURE_FAILED</td>
    <td>87h</td>
    <td>Returned when there was insufficient storage space to add the desired structure.</td>
  </tr>
  <tr>
    <td>DMI_READ_ONLY</td>
    <td>8Dh</td>
    <td>A "Set SMBIOS Structure" request failed because one or more of the to-be-changed structure fields are read-only.</td>
  </tr>
  <tr>
    <td>DMI_LOCK_NOT_SUPPORTED</td>
    <td>90h</td>
    <td>The GPNV functions do not support locking for the specified GPNV handle.</td>
  </tr>
  <tr>
    <td>DMI_CURRENTLY_LOCKED</td>
    <td>91h</td>
    <td>The GPNV lock request failed - the GPNV is already locked.</td>
  </tr>
  <tr>
    <td>DMI_INVALID_LOCK</td>
    <td>92h</td>
    <td>The caller has failed to present the predefined GPNVLock value which is expected by the BIOS for access of the GPNV area.</td>
  </tr>
</table>
2.2.3 SMBIOS Structure Access Interface

2.2.3.1 Function 50h – Get SMBIOS Information

Synopsis:
short FAR (*entryPoint)(
    short Function,
    unsigned char FAR *dmiBIOSRevision,
    unsigned short FAR *NumStructures,
    unsigned short FAR *StructureSize,
    unsigned long FAR *dmiStorageBase,
    unsigned short FAR *dmiStorageSize,
    unsigned short BiosSelector );
    /* PnP BIOS Function 50h */
    /* Revision of the SMBIOS Extensions */
    /* Max. Number of Structures the BIOS will */
    /* return */
    /* Size of largest SMBIOS Structure */
    /* 32-bit physical base address for memory- */
    /* mapped SMBIOS data */
    /* Size of the memory-mapped SMBIOS data */
    /* PnP BIOS readable/writable selector */

Description:
Required for SMBIOS Calling Interface Support. This function will return the revision of the SMBIOS Extensions and the maximum number of SMBIOS structures that the system BIOS will return information for in NumStructures. These structures represent the SMBIOS information that is embedded in the System BIOS. In addition to the number of structures, the system BIOS will return the size, in bytes, of the largest SMBIOS structure (and all of its supporting data) in StructureSize. This information can be utilized by the system software to determine the amount of memory required to get all of the SMBIOS structures. Note: The system BIOS may return a value that is larger than the actual largest SMBIOS structure to facilitate hot docking or other dynamic SMBIOS information. The BIOS may also return fewer than NumStructures when the structures are retrieved using Function 51h. If the BIOS does not support SMBIOS calling interface capability, DMI_FUNCTION_NOT_SUPPORTED (82h) will be returned.

The dmiBIOSRevision parameter indicates compliance with a revision of this specification. It is a BCD value where the upper nibble indicates the major version and the lower nibble the minor version. For revision 2.0 the returned value will be 20h.

dmiStorageBase is updated by the BIOS call with the paragraph-aligned, 32-bit absolute physical base address of any memory-mapped SMBIOS structure information. If non-zero, this value allows the caller to construct a 16-bit data segment descriptor with a limit of dmiStorageSize and read/write access for subsequent input to functions 51h to 54h. If dmiStorageBase is 0, protected-mode mapping is not required.

In addition, dmiStorageSize identifies the dmiWorkBuffer size for input to function 52h and the Data buffer size for function 54h’s DMI_CLEAR_EVENT_LOG2 sub-function. Note: This feature is SMBIOS version-specific; for v2.0 implementations, the value of dmiStorageSize has no meaning if dmiStorageBase is 0. In this case, the buffer-sizing is provided by (NumStructures * StructureSize).

The BiosSelector parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space. If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable. If this function is called from real mode, BiosSelector should be set to the Real mode 16-bit data segment address as specified in the Plug and Play Installation Check Structure. Refer to section 4.4 of the Plug and Play BIOS Specification revision 1.0a for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.

This function is available in real mode and 16-bit protected mode.
Returns:
If successful - DMI_SUCCESS
If an Error (Bit 7 set) or a Warning occurred the Error Code will be returned in AX, the FLAGS and all other registers will be preserved.

Example:
The following example illustrates how the 'C' style call interface could be made from an assembly language module:

push    BiosSelector
push    segment/selector of dmiStorageSize        ; Pointer to DMIStorageSize
push    offset of dmiStorageSize
push    segment/selector of dmiStorageBase         ; Pointer to DMIStorageBase
push    offset of dmiStorageBase
push    segment/selector of StructureSize          ; Pointer to StructureSize
push    offset of StructureSize
push    segment/selector of NumStructures          ; Pointer to NumStructures
push    offset NumStructures
push    segment/selector of dmiBIOSRevision        ; Pointer to DMIBIOSRevision
push    offset dmiBIOSRevision
push    GET_DMI_INFORMATION                       ; Function number, 50h
call    FAR PTR entryPoint
add     sp, 24                                    ; Clean up stack
cmp     ax, DMI_SUCCESS                           ; Function completed successfully?
jne     error

2.2.3.2 Function 51h – Get SMBIOS Structure

Synopsis:
short FAR (*entryPoint)(
    short Function,                                 /* PnP BIOS Function 51h */
    unsigned short FAR *Structure,                   /* Structure number/handle to retrieve*/
    unsigned char FAR *dmiStrucBuffer,               /* Pointer to buffer to copy structure data */
    unsigned short dmiSelector,                      /* SMBIOS data read/write selector */
    unsigned short BiosSelector );                   /* PnP BIOS readable/writable selector */

Description:
Required for SMBIOS Calling Interface Support. This function will copy the information for the specified SMBIOS Structure into the buffer specified by the caller. The Structure argument is a pointer to the unique SMBIOS Structure number (handle). If Structure contains zero, the system BIOS will return the first SMBIOS Structure. The dmiStrucBuffer argument contains the pointer to the caller’s memory buffer. If the function returns either DMI_SUCCESS or DMI_INVALID_HANDLE, Structure is updated with either the next sequential structure handle or the end-of-list indicator 0FFFFh.

The protected-mode read/write selector dmiSelector has base equal to dmiStorageBase and limit of at least dmiStorageSize — so long as the dmiStorageBase value returned from Function 50h was non-zero.

The BiosSelector parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space. If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable. If this function is called from real mode, BiosSelector should be set to the Real mode 16-bit data segment address as specified in the Plug and Play Installation Check Structure. Refer to section 4.4 of the Plug and Play BIOS Specification revision 1.0a for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.

This function is available in real mode and 16-bit protected mode.

Returns:
If successful DMI_SUCCESS
If an Error (Bit 7 set) or a Warning occurred, the Error Code will be returned in AX, the FLAGS and all other registers will be preserved
Example:
The following example illustrates how the ‘C’ style call interface could be made from an assembly language module:

push      BiosSelector
push      dmiSelector
push      segment/selector of dmiStrucBuffer    ; Pointer to dmiStrucBuffer
push      offset of dmiStrucBuffer
push      segment/selector of Structure ; Pointer to Structure
push      offset of Structure
push      GET_DMI_STRUCTURE                ; Function number, 51h
call      FAR PTR entryPoint
add       sp, 14                           ; Clean up stack
cmp       ax, DMI_SUCCESS                   ; Function completed successfully?
jne       error

2.2.3.3 Function 52h – Set SMBIOS Structure

Synopsis:
short FAR (*entryPoint)(
    short Function,                                 /* PnP BIOS Function 52h */
    unsigned char FAR *dmiDataBuffer,   /* Pointer to buffer with new/change data */
    unsigned char FAR *dmiWorkBuffer,   /* Pointer to work buffer area for the BIOS */
    unsigned char Control,                /* Conditions for performing operation */
    unsigned short dmiSelector,           /* SMBIOS data read/write selector */
    unsigned short BiosSelector );        /* PnP BIOS readable/writeable selector */

Description:
Optional. This function will set the SMBIOS structure identified by the type (and possibly handle) found in the SMBIOS structure header in the buffer pointed to by dmiDataBuffer. Values that the BIOS allows to be set in the supplied structure will either be updated by the call, or will cause the BIOS to perform some defined action (such as enabling a hardware option, etc.).

Unless otherwise specified, all structures and structure values defined in Section 3, SMBIOS Structures, are read-only and cannot be set. Attempts to set these structures will return a DMI_READ_ONLY error. A structure field that is composed of read/write and read-only subfields can still be set -- so long as the read-only portion of the field is unmodified. Attempting to write to a read-only subfield will also cause a DMI_READ_ONLY to be returned.
The dmiDataBuffer parameter references a structure of the following format:

<table>
  <tr>
    <th>Offset</th>
    <th>Field</th>
    <th>Length</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td><i>Command</i></td>
    <td>BYTE</td>
    <td>Identifies the structure-setting operation to be performed, one of:<br>
      00h A single byte of information is to be changed in the structure identified by StructureHeader<br>
      01h A word (two bytes) of information is to be changed in the structure identified by StructureHeader<br>
      02h A double-word (four bytes) of information is to be changed in the structure identified by StructureHeader<br>
      03h The structure identified by StructureHeader is to be added to the SMBIOS structure pool<br>
      04h The structure identified by StructureHeader is to be deleted from the SMBIOS structure pool<br>
      05h A string's value is to be changed in the structure identified by StructureHeader.<br>
      06h A block of information (other than byte, word, or dword in size) is to be changed in the structure identified by StructureHeader.<br>
      07h-0FFh Reserved for future assignment by this specification.
    </td>
  </tr>
  <tr>
    <td>01h</td>
    <td><i>FieldOffset</i></td>
    <td>BYTE</td>
    <td>For a structure change Command, identifies the starting offset within the changed structure's fixed data of the to-be-changed item. For a string-value change Command, identifies the offset within the structure's fixed data associated with the string's "number". This field is ignored for all other Commands.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td><i>ChangeMask</i></td>
    <td>DWORD</td>
    <td>For a fixed-length structure-change Command, identifies the ANDing mask to be applied to the existing structure data prior to applying the ChangeValue. The number of significant bytes within this area is defined by the Command. This field is ignored for all other Commands.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td><i>ChangeValue</i></td>
    <td>DWORD</td>
    <td>For a fixed-length structure-change Command, identifies the data value to be ORed with the existing structure data – after applying the ChangeMask. The number of significant bytes within this area is defined by the Command. This field is ignored for all other Commands.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td><i>DataLength</i></td>
    <td>WORD</td>
    <td>For a structure-add Command, identifies the full length of the to-be-added structure. The length includes the structure header, the fixed-length portion of the structure, and any string data that accompanies the added structure – including all null-terminators. For a string-value change Command, identifies the length of the string data (including the null-terminator); if the length is 1 (indicating that only the null-terminator is provided), the current string's data is deleted so long as the string's data-access rights are met. For a variable-length block change Command, identifies the length of the contiguous data block to be changed. This field is ignored for all other Commands.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td><i>StructureHeader</i></td>
    <td>4 BYTES</td>
    <td>Contains the structure header (see <i>Structure Header Format</i> on page 30) of the structure to be added, changed, or deleted.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td><i>StructureData</i></td>
    <td>Var</td>
    <td>For a structure-add Command, contains the data to be associated with the SMBIOS Structure identified by the StructureHeader. For a string-value change Command, contains the string's data (the number of characters is identified by DataLength). For a variable-length block change Command, contains the block's data (the number of bytes is identified by DataLength). This field is ignored for all other Commands.</td>
  </tr>
</table>

The dmiWorkBuffer parameter references a work buffer for use by the BIOS in performing the request; the contents of the buffer are destroyed by the BIOS' processing. This work buffer must be read/write and sized to hold the entire SMBIOS structure pool, based on the information returned by <i>Function 50h</i> –
Get SMBIOS Information (see page 16) plus the size of any structure to be added by the request. For SMBIOS v2.0 implementations, the pool size is specified by the maximum of (StructureSize * NumStructures) and (when dmiStorageBase is non-zero) dmiStorageSize; for v2.1 and later implementations, the pool size is specified by dmiStorageSize.

The Control flag provides a mechanism for indicating to the BIOS whether the set request is to take effect immediately, or if this is a check to validate the to-be-updated data.

Control is defined as:

Bit    0      0 = Do not set the specified structure, but validate its parameters.
        1 = Set the structure immediately.
Bits 1:7 Reserved, must be 0.

If bit 0 of Control is 0, then the dmiDataBuffer values are checked for validity. If any are not valid, then the function returns DMI_BAD_PARAMETER; if any read-only field is modified, the function returns DMI_READ_ONLY. Validity checking is useful to determine if the BIOS supports setting a structure field to a particular value – or whether the BIOS supports writing to a specific structure field. For example, it may be useful for an OEM to determine beforehand whether the OEM's BIOS supports a "Reboot to Diagnostics Now" setting in an OEM-defined structure.

The protected-mode read/write selector dmiSelector has base equal to dmiStorageBase and a limit of at least dmiStorageSize, so long as the dmiStorageBase returned from Function 50h – Get SMBIOS Information was non-zero.

The BiosSelector parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space. If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable. If this function is called from real mode, BiosSelector should be set to the Real mode 16-bit data segment address as specified in the Plug and Play Installation Check Structure. Refer to section 4.4 of the Plug and Play BIOS Specification revision 1.0a for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.

This function is available in real mode and 16-bit protected mode.

Note: If the system BIOS supports structure-change notification, a structure-change event will be issued by the BIOS upon its successful completion of a structure-setting (rather than validation) function call. See Structure Change Notification Interface on page 21 for more information.

Returns:
If successful - DMI_SUCCESS
If an error occurred, the Error Code will be returned in AX. The FLAGS and all other registers will be preserved.

Errors:
DMI_BAD_PARAMETER        A parameter contains an invalid or unsupported value.
DMI_READ_ONLY            A parameter is read-only and differs from the present value – an attempt was made to modify a read-only value.
DMI_ADD_STRUCTURE_FAILED The desired structure could not be added due to insufficient storage space.
DMI_INVALID_HANDLE       For an add (03h) Command, the structure handle present in the StructureHeader already exists or, for a change (00h to 02h and 05h) or delete (04h) Command, the structure handle does not exist.
Example:
The following example illustrates how the 'C' style call interface could be made from an assembly language module:

push      BiosSelector
push      dmiSelector
push      Control
push      segment/selector of dmiWorkBuffer ;pointer to BIOS temporary buffer
push      offset of dmiWorkBuffer
push      segment/selector of dmiDataBuffer ; pointer to structure
push      offset of dmiDataBuffer
push      SET_DMI_STRUCTURE ; Function number, 52h
call      FAR PTR entryPoint
add       sp, 16 ; clean stack
cmp       ax, DMI_SUCCESS ; Successful?
jne       error ; No, go handle error

2.2.4 Structure Change Notification Interface

Certain classes of systems may provide the capability for the addition or removal of system devices while the system unit is powered on, such as inserting a Notebook unit into a Docking Station. System BIOS support is necessary for providing SMBIOS Structure Change Notification accessible to system software so that when devices are added or removed the system software will comprehend any changes in the SMBIOS Structures. Structure Change Notification can be implemented as either a polled method or as asynchronous Plug-and-Play events. For information on how Plug-and-Play event notification is accessed, see section 4.6 of the Plug and Play BIOS Specification revision 1.0a.

When system software is notified on an event by either mechanism, it can then call the BIOS runtime function (Plug and Play BIOS Function 3 - Get Event) to get the type of event. In addition to the events defined in the Plug and Play BIOS Specification, the following event has been defined.

Note: Some DMI structure values might be inherently changing (e.g. an OEM-specific structure which returns system temperature and voltage values). Due to the frequency of the values’ change, the BIOS might not return Structure Change status for this type of structure.

DMI_STRUCTURE_CHANGE_EVENT    7FFFh

This message indicates that there has been a change in the DMI Information being maintained by the System BIOS. Upon receiving a DMI_STRUCTURE_CHANGE_EVENT, system software can call the BIOS runtime function 53h (Get Structure Change Information) to determine the exact cause of the SMBIOS structure-change event.

2.2.4.1 Function 53h – Get Structure Change Information

Synopsis:
short FAR (*entryPoint)(
    short Function,                /* PnP BIOS Function 53h */
    unsigned char FAR *dmiChangeStructure, /* Pointer to SMBIOS Change structure */
    unsigned short dmiSelector,     /* SMBIOS data read/write selector */
    unsigned short BiosSelector );   /* PnP BIOS readable/writable selector */

Description:
Required for SMBIOS Dynamic Structure Change Notification Support. This function will allow system software to get information about what type of SMBIOS structure-change occurred. The SMBIOS structure-change information will be returned in the 16-byte memory buffer pointed to by dmiChangeStructure in the following format:

<table>
  <tr>
    <th>Field</th>
    <th>Offset</th>
    <th>Length</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>SMBIOS Change Status</td>
    <td>00h</td>
    <td>BYTE</td>
    <td>ENUM</td>
  </tr>
</table>
<table>
  <tr>
    <th>Field</th>
    <th>Offset</th>
    <th>Length</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>SMBIOS Change Type</td>
    <td>01h</td>
    <td>BYTE</td>
    <td>Bit Field</td>
  </tr>
  <tr>
    <td>SMBIOS Structure Handle</td>
    <td>02h</td>
    <td>WORD</td>
    <td>Varies</td>
  </tr>
  <tr>
    <td>Reserved</td>
    <td>04h-0Fh</td>
    <td>12 BYTES</td>
    <td>00h</td>
  </tr>
</table>

SMBIOS Change Status:
00h    No Change
01h    Other
02h    Unknown
03h    Single SMBIOS Structure Affected
04h    Multiple SMBIOS Structures Affected
05h - 0FFh    Reserved

SMBIOS Change Type:
Bit 0    One or more structures was changed, when 1.
Bit 1    One or more structures was added, when 1. See “Function 52h – Set DMI Structure” for information about adding SMBIOS structures.
Byte 2:7    Reserved, must be 0

If DMI Change Status 03h (Single Structure Affected) is returned, the number (or handle) of the affected structure is present in the "DMI Structure Handle" field; DMI Change Type identifies whether the structure was changed (01h) or added (02h).

If DMI Change Status 04h (Multiple DMI Structures Affected) is returned, the caller must enumerate all the structures to determine what was changed and/or added. DMI Change Type identifies whether multiple structures were changed (01h), multiple structures were added (02h), or structures were both changed and added (03h).

The DMI Change Status Byte remains valid until Function 53h is called. The calling of Function 53h will reset the DMI Change Status Byte to zero. If the call is issued in the absence of a DMI event, the function returns error code 86h (DMI_NO_CHANGE).

The protected-mode read/write selector dmiSelector has base equal to dmiStorageBase and limit of at least dmiStorageSize — so long as the dmiStorageBase value returned from Function 50h was non-zero.

The BiosSelector parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space. If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable. If this function is called from real mode, BiosSelector should be set to the Real mode 16-bit data segment address as specified in the Plug and Play Installation Check Structure. Refer to section 4.4 of the Plug and Play BIOS Specification revision 1.0a for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.

This function is available in real mode and 16-bit protected mode.

Returns:
If successful - DMI_SUCCESS
If an Error (Bit 7 set) or a Warning occurred the Error Code will be returned in AX, the FLAGS and all other registers will be preserved
Example:
The following example illustrates how the ‘C’ style call interface could be made from an assembly language module:

push        BiosSelector
push        dmiSelector
push        segment/selector of dmiChangeStructure
push        offset of dmiChangeStructure
push        GET_DMI_STRUCTURE_CHANGE_INFO      ; Function number, 53h
call        FAR PTR entryPoint
add         sp, 10                              ; Clean up stack
cmp         ax, DMI_SUCCESS                     ; Function completed successfully?
jne         error

2.2.5 Control Interface

2.2.5.1 Function 54h – SMBIOS Control

Synopsis:
short FAR (*entryPoint)(
    short Function,                /* PnP BIOS Function 54h */
    short SubFunction,              /* Defines the specific control operation */
    void FAR *Data,                 /* Input/output data buffer, SubFunction specific */
    unsigned char Control,          /* Conditions for setting the structure */
    unsigned short dmiSelector,     /* SMBIOS data read/write selector */
    unsigned short BiosSelector );   /* PnP BIOS readable/writeable selector */

Description:
Optional. This function provides the interface to perform implementation-specific functions for the system, as defined by the SubFunction parameter and its (optional) Data values.

<table>
  <tr>
    <th>SubFunction</th>
    <th>Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0000h</td>
    <td>DMI_CLEAR_EVENT_LOG</td>
    <td>Clears the event log as described in System Event Log (Type 15) on page 61. The Data parameter is reserved and must be set to 0.</td>
  </tr>
  <tr>
    <td>0001h</td>
    <td>DMI_CONTROL_LOGGING</td>
    <td>Data points to a 2-word (4-byte) buffer that describes how to control event logging – see 2.2.5.1.1 for bit-wise definitions. The first word (offset 0:1) identifies the ANDing mask to be applied to the existing log-control value prior to ORing the second word (offset 2:3). The second word is modified by the BIOS to contain the log-control value on entry to this function.</td>
  </tr>
  <tr>
    <td>0002h</td>
    <td>DMI_CLEAR_EVENT_LOG2</td>
    <td>Clears the event log as described in System Event Log (Type 15) on page 61. The Data parameter is the 32-bit physical address of a work buffer needed to perform this operation. The buffer must be read/write and sized to hold dmiStorageSize bytes. The contents of the buffer are destroyed by the BIOS processing. This sub-function is defined for v2.1 and later implementations of this specification and is preferred over the DMI_CLEAR_EVENT_LOG (0000h) sub-function.</td>
  </tr>
  <tr>
    <td>0003h-3FFFh</td>
    <td>Reserved</td>
    <td>Reserved for future definition by this specification.</td>
  </tr>
  <tr>
    <td>4000h-7FFFh</td>
    <td>Reserved for BIOS vendor</td>
    <td>Available for use by the BIOS vendor.</td>
  </tr>
  <tr>
    <td>8000h-FFFFh</td>
    <td>Reserved for system vendor</td>
    <td>Available for use by the system vendor.</td>
  </tr>
</table>

Note: A BIOS might support the Log Control function but not support all the SubFunction values.
The Control flag provides a mechanism for indicating to the BIOS whether the operation is to be performed immediately, or if this is a check to validate the operation’s availability and/or data.

Control is defined as:

Bit    0      0 = Do not perform the operation, but validate its parameters.
        1 = Perform the operation immediately.
Bits 1:7  Reserved, must be 0.

If bit 0 of Control is 0, then the SubFunction and contents of Data are checked for validity. If any are not valid, then the function returns DMI_BAD_PARAMETER. Validity checking is useful to determine if the BIOS supports a specific DMI Control SubFunction.

The protected-mode read/write selector dmiSelector has base equal to dmiStorageBase and limit of at least dmiStorageSize — so long as the dmiStorageBase value returned from Function 50h was non-zero.

The BiosSelector parameter enables the system BIOS, if necessary, to update system variables that are contained in the system BIOS memory space. If this function is called from protected mode, the caller must create a data segment descriptor using the 16-bit Protected Mode data segment base address specified in the Plug and Play Installation Check data structure, a limit of 64KB, and the descriptor must be read/write capable. If this function is called from real mode, BiosSelector should be set to the Real mode 16-bit data segment address as specified in the Plug and Play Installation Check Structure. Refer to section 4.4 of the Plug and Play BIOS Specification revision 1.0a for more information on the Plug and Play Installation Check Structure and the elements that make up the structure.

This function is available in real mode and 16-bit protected mode.

Returns:
If successful - DMI_SUCCESS
If an error occurred, the Error Code will be returned in AX. The FLAGS and all other registers will be preserved.

Errors:
DMI_BAD_PARAMETER    The Data contents were not valid for the requested SubFunction.
DMI_INVALID_SUBFUNCTION The SubFunction requested is not supported by the system BIOS.

Example:
The following example illustrates how the 'C' style call interface could be made from an assembly language module:

push    BiosSelector
push    dmiSelector
push    Control
push    segment/selector of Data ; pointer to SubFunction data
push    offset of Data
push    SubFunction
push    DMI_CONTROL ; Function number, 54h
call    FAR PTR entryPoint
add     sp, 14 ; clean stack
cmp     ax, DMI_SUCCESS ; Successful?
jne     error ; No, go handle error

2.2.5.1.1 DMI_CONTROL_LOGGING Control Word

<table>
  <tr>
    <th>Word Bit Position</th>
    <th>Meaning if Set</th>
  </tr>
  <tr>
    <td>0</td>
    <td>Enable Event Logging (overall)</td>
  </tr>
  <tr>
    <td>1</td>
    <td>Enable Correctable Memory Error Events’ Logging</td>
  </tr>
  <tr>
    <td>2</td>
    <td>Disable the logging of POST errors</td>
  </tr>
  <tr>
    <td>3 - 15</td>
    <td>Reserved for future assignment by this specification, set to 0.</td>
  </tr>
</table>
2.2.6 General Purpose Nonvolatile Storage Interface

A General-Purpose NonVolatile (GPNV) area is a persistent general-purpose storage area managed by the System Management BIOS. Multiple GPNV areas can be supported by a particular BIOS implementation. The size, format and location of a GPNV are not defined by this specification nor is the number of GPNV areas — these attributes are OEM-specific.

A GPNV storage area is not a requirement for a System Management BIOS. It is one method that might be used to store the System Event Log (see section 3.3.16, page 61). A GPNV storage area is not necessarily dedicated to the System Management functions of the BIOS, it can also be used by other services which require non-volatile storage.

A Handle parameter is passed into the GPNV function calls to specify which GPNV area is to be accessed. The Handle for the first GPNV area is 0, with remaining GPNV areas identified by Handle values 1, 2, 3... n, where (n+1) is the total number of GPNV areas supported by a particular BIOS implementation.

A GPNVLock parameter provides a mechanism for cooperative use of the GPNV. The GPNVLock value is set on a Read GPNV request (function 56h) and cleared on a Write GPNV request (function 57h). The BIOS compares the value of the GPNVLock which is set on a Read GPNV request with the value of the GPNVLock passed as a parameter into the GPNV Write request — if they match, the GPNV Write request succeeds and the GPNV data area will be updated on completion of the GPNV Write; if the lock values do not match, the BIOS does not update the GPNV area and DMI_CURRENTLY_LOCKED is returned. Note: GPNV locks are held until unlocked, even through system power and reboot cycles. The method used to preserve the GPNV Locks through boot cycles is left up to the system designer.

A BIOS might choose to “hide” a GPNV area by defining a special lock value which is required to access the area. In this case, the special GPNVLock value must be supplied with the GPNV read and write requests or the function is failed by the BIOS with DMI_INVALID_LOCK.

A lock set request succeeds when there is no outstanding lock set at the time that the Read GPNV request (Function 56h) is made. A lock set request fails when there is already a lock set as the result of a previous Read GPNV request (which has not yet been cleared with a Function 57h Write GPNV request) or when a predefined lock value is required in order to access a particular GPNV area and the GPNVLock value provided by the caller does not match the required value.

The BIOS makes no attempt to enforce mutually-exclusive access to the GPNV — it is up to callers of GPNV Read to ensure unique GPNVLock values (e.g. process ID).

2.2.6.1 Function 55H – Get General-Purpose NonVolatile Information

Synopsis:
short FAR (*entryPoint)(
    short Function,                /* PnP BIOS Function 55h */
    unsigned short FAR *Handle,    /* Identifies which GPNV to access */
    unsigned short FAR *MinGPNVRWSize, /* Minimum buffer size in bytes for GPNV access */
    unsigned short FAR *GPNVSsize, /* Size allocated for GPNV within the R/W Block */
    unsigned long FAR *NVStorageBase, /* 32-bit physical base address for... */
    /* ... mem. mapped nonvolatile storage media */
    unsigned short BiosSelector );   /* PnP BIOS readable/writable selector */

Description: Required for GPNV support. This function returns information about a General Purpose NonVolatile (GPNV) area. The Handle argument is a pointer to a number that identifies which GPNV’s information is requested, a value of 0 accesses the first (or only) area.
On return:
*Handle is updated either with the handle of the next GPNV area or, if there are no more areas, 0FFFFh. GPNV handles are assigned sequentially by the system, from 0 to the total number of areas (minus 1).
*MinGPNVRWSize is updated with the minimum size, in bytes, of any buffer used to access this GPNV area. For a Flash based GPNV area, this would be the size of the Flash block containing the actual GPNV.
*GPNVSize is updated with the size, in bytes, of this GPNV area (which is less than or equal to the MinGPNVRWSize value).
*NVStorageBase is updated with the paragraph-aligned, 32-bit absolute physical base address of this GPNV. If non-zero, this value allows the caller to construct a 16-bit data segment descriptor with a limit of MinGPNVRWSize and read/write access. If the value is 0, protected-mode mapping is not required for this GPNV.

Returns:
If successful - DMI_SUCCESS
If an Error (Bit 7 set) or a Warning occurred the Error Code will be returned in AX, the FLAGS and all other registers will be preserved

Example:
The following example illustrates how the 'C' style call interface could be made from an assembly language module:

push    BiosSelector
push    segment/selector of NVStorageBase
push    offset of NVStorageBase
push    segment/selector of GPNVSize
push    offset of GPNVSize
push    segment/selector of MinGPNVRWSize
push    offset of MinGPNVRWSize
push    segment/selector of Handle
push    offset of Handle
push    GET_GPNV_INFORMATION ; Function number, 55h
call    FAR PIR entryPoint
add     sp, 20                ; Clean up stack
cmp     ax, DMI_SUCCESS        ; Function completed successfully?
jne     error

2.2.6.2 Function 56H – Read General-Purpose NonVolatile Data

Synopsis:
short FAR (*entryPoint)(
    short Function,                /* PnP BIOS Function 56h */
    unsigned short Handle,          /* Identifies which GPNV is to be read */
    unsigned char FAR *GPNVBuffer,  /* Address of buffer in which to return GPNV */
    short FAR *GPNVLock,            /* Lock value */
    unsigned short GPNVSelector,    /* Selector for GPNV Storage */
    unsigned short BiosSelector );   /* PnP BIOS readable/writable selector */

Description: Required for GPNV support. This function is used to read an entire GPNV area into the buffer specified by GPNVBuffer. It is the responsibility of the caller to ensure that GPNVBuffer is large enough to store the entire GPNV storage block - this buffer must be at least the MinGPNVRWSize returned by Function 55h - Get GPNV Information. The Handle argument identifies the specific GPNV to be read. On a successful read of a GPNV area, that GPNV area will be placed in the GPNVBuffer beginning at offset 0. The protected-mode selector GPNVSelector has base equal to NVStorageBase and limit of at least MinGPNVRWSize — so long as the NVStorageBase value returned from Function 55h was non-zero.

Passing a GPNVLock value of -1 to the GPNV Read causes the GPNVLock value to be ignored — in this case the underlying logic makes no attempt to store a lock value for comparison with lock values passed
into GPNV Write. Any value provided for GPNVLock besides -1 is accepted as a valid value for a lock request.

Returns:
If the GPNV lock is supported and the lock set request succeeds, the caller’s GPNVLock is set to the value of the current lock and the function returns DMI_SUCCESS.

If the GPNV request fails, one of the following values is returned:
• DMI_LOCK_NOT_SUPPORTED
• DMI_INVALID_LOCK
• DMI_CURRENTLY_LOCKED

For return status codes DMI_SUCCESS, DMI_LOCK_NOT_SUPPORTED and DMI_CURRENTLY_LOCKED, the GPNV Read function returns the current contents of the GPNV associated with Handle as the first GPNVSize bytes within GPNVBuffer, starting at offset 0. If a lock request fails with DMI_CURRENTLY_LOCKED status, the caller’s GPNVLock will be set to the value of the current lock.

Example:
The following example illustrates how the ‘C’ style call interface could be made from an assembly language module:

push    BiosSelector
push    GPNVSelector
push    segment/selector of GPNVLock
push    offset of GPNVLock
push    segment/selector of GPNVBuffer
push    offset of GPNVBuffer
push    Handle
push    READ_GPNV_DATA           ; Function number, 56h
call    FAR PTR entryPoint
add     sp, 16                   ; Clean up stack
cmp     ax, DMI_SUCCESS          ; Function completed successfully?
jne     error

2.2.6.3 Function 57H – Write General-Purpose NonVolatile Data

Synopsis:
short FAR (*entryPoint)(
    short Function,                /* PnP BIOS Function 57h */
    unsigned short Handle,          /* Identifies which GPNV is to be written */
    unsigned char FAR *GPNVBuffer, /* Address of buffer containing complete GPNV to write*/
    short GPNVLock,                /* Lock value */
    unsigned short GPNVSelector,    /* Selector for GPNV Storage */
    unsigned short BiosSelector );  /* PnP BIOS readable/writable selector */

Description: Required for GPNV support. This function is used to write an entire GPNV from the GPNVBuffer into the nonvolatile storage area. The Handle argument identifies the specific GPNV to be written. The protected-mode selector GPNVSelector has base equal to NVStorageBase and limit of at least MinGPNVRWSIZE — so long as the NVStorageBase value returned from Get GPNV Information was non-zero. The caller should first call Read GPNV Data (with a lock) to get the current area contents, modify the data, and pass it into this function — this ensures that the GPNVBuffer which is written contains a complete definition for the entire GPNV area. If the BIOS uses some form of block erase device, the caller must also allocate enough buffer space for the BIOS to store all data from the part during the reprogramming operation, not just the data of interest.

The data to be written to the GPNV selected by Handle must reside as the first GPNVSize bytes of the GPNVBuffer. Note: The remaining (MinGPNVRWSIZE-GPNVSize) bytes of the GPNVBuffer area are
used as a scratch-area by the BIOS call in processing the write request; the contents of that area of the buffer are destroyed by this function call.

The GPNVLock provides a mechanism for cooperative use of the GPNV, and is set during a GPNV Read (Function 56h). If the input GPNVLock value is -1 the caller requests a forced write to the GPNV area, ignoring any outstanding GPNVLock. If the caller is not doing a forced write, the value passed in GPNVLock to the GPNV Write must be the same value as that (set and) returned by a previous GPNV Read (Function 56h).

Returns:
The GPNV Write function returns a value of DMI_LOCK_NOT_SUPPORTED when a GPNVLock value other than -1 is specified and locking is not supported. A return status of DMI_CURRENTLY_LOCKED indicates that the call has failed due to an outstanding lock on the GPNV area which does not match the caller’s GPNVLock value. Any outstanding GPNVLock value (which was set by a previous Function 56H – Read General-Purpose NonVolatile Data) gets cleared on a successful write of the GPNV.

Example:
The following example illustrates how the ‘C’ style call interface could be made from an assembly language module:

push    BiosSelector
push    GPNVSelector
push    GPNVLock
push    segment/selector of GPNVBuffer
push    offset of GPNVBuffer
push    Handle
push    WRITE_GPNV_DATA        ; Function number, 57h
call    FAR PTR entryPoint
add     sp, 14                 ; Clean up stack
cmp     ax, DMI_SUCCESS         ; Function completed successfully?
jne     error
3. SMBIOS Structures

The total number of structures can be obtained either through the Get SMBIOS Information function (see 2.2.3.1 on page 16) or from the SMBIOS Entry Point Structure (see 2.1 Table Convention on page 13). The System Information is presented to an application as a set of structures that are obtained by either calling the Get SMBIOS Structure function once per structure (see 2.2.3.2 on page 17) or by traversing the SMBIOS structure table referenced by the SMBIOS Entry Point Structure (see 2.1 Table Convention on page 13).

3.1 Structure Standards

Each SMBIOS structure has a formatted section and an optional unformed section. The formatted section of each structure begins with a 4-byte header. Remaining data in the formatted section is determined by the structure type, as is the overall length of the formatted section.

3.1.1 Structure Evolution and Usage Guidelines

As the industry evolves, the structures defined in this specification will evolve. To ensure that the evolution occurs in a nondestructive fashion, the following guidelines must be followed:

1. If a new field is added to an existing structure, that field is added at the end of the formatted area of that structure and the structure’s Length field is increased by the new field’s size.

2. Any software which interprets a structure shall use the structure’s Length field to determine the formatted area size for the structure rather than hard-coding or deriving the Length from a structure field.

3. Each structure shall be terminated by a double-null (0000h), either directly following the formatted area (if no strings are present) or directly following the last string. This includes system- and OEM-specific structures and allows upper-level software to easily traverse the structure table. See below for structure-termination examples.

4. The unformed section of the structure is used for passing variable data such as text strings, see 3.1.3 Text Strings for more information.

5. When an enumerated field’s values are controlled by the DMTF, new values can be used as soon as they are defined by the DMTF without requiring an update to this specification.

6. Starting with v2.3, each SMBIOS structure type has a minimum length — enabling the addition of new, but optional, fields to SMBIOS structures. In no case shall a structure’s length result in a field being less than fully populated. For example, a Voltage Probe structure with Length of 15h is invalid since the Nominal Value field would not be fully specified.

Software that interprets a structure field must verify that the structure’s length is sufficient to encompass the optional field; if the length is insufficient, the optional field’s value as Unknown. For example, if a Voltage Probe structure has a Length field of 14h, the probe’s Nominal Value is Unknown. A Voltage Probe structure with Length greater than 14h always includes a Nominal Value field.
Example: BIOS Information with strings

BIOS_Info    LABEL BYTE
db 0           ; Indicates BIOS Structure Type
db 13h         ; Length of information in bytes
dw ?           ; Reserved for handle
db 01h         ; String 1 is the Vendor Name
db 02h         ; String 2 is the BIOS version
dw 0E800h      ; BIOS Starting Address
db 03h         ; String 3 is the BIOS Build Date
db 1           ; Size of BIOS ROM is 128K (64K * (1 + 1))
dq BIOS_Char   ; BIOS Characteristics
db 0           ; BIOS Characteristics Extension Byte 1
db 'System BIOS Vendor Name',0 ;
db '4.04',0     ;
db '00/00/0000',0 ;
db 0           ; End of strings

Example: BIOS Information without strings (example-only)

BIOS_Info    LABEL BYTE
db 0           ; Indicates BIOS Structure Type
db 13h         ; Length of information in bytes
dw ?           ; Reserved for handle
db 00h         ; No Vendor Name provided
db 00h         ; No BIOS version provided
dw 0E800h      ; BIOS Starting Address
db 00h         ; No BIOS Build Date provided
db 1           ; Size of BIOS ROM is 128K (64K * (1 + 1))
dq BIOS_Char   ; BIOS Characteristics
db 0           ; BIOS Characteristics Extension Byte 1
dw 0000h       ; Structure terminator

3.1.2 Structure Header Format

Each SMBIOS structure begins with a 4-byte header, as follows:

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>Specifies the type of structure. Types 0 through 127 (7Fh) are reserved for and defined by this specification. Types 128 through 256 (80h to FFh) are available for system- and OEM-specific information.</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Specifies the length of the formatted area of the structure, starting at the Type field. The length of the structure's string-set is not included.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Specifies the structure's handle, a unique 16-bit number in the range 0 to 0FFFFh (for version 2.0) or 0 to OFFFFh (for version 2.1 and later). The handle can be used with the Get SMBIOS Structure function to retrieve a specific structure; the handle numbers are not required to be contiguous. For v2.1 and later, handle values in the range 0FF00h to OFFFFh are reserved for use by this specification.<br><br>If the system configuration changes, a previously assigned handle might no longer exist. However once a handle has been assigned by the BIOS, the BIOS cannot re-assign that handle number to another structure.</td>
  </tr>
</table>

3.1.3 Text Strings

Text strings associated with a given SMBIOS structure are returned in the dmiStrucBuffer, appended directly after the formatted portion of the structure. This method of returning string information eliminates the need for application software to deal with pointers embedded in the SMBIOS structure. Each string is terminated with a null (00h) BYTE and the set of strings is terminated with an additional null (00h) BYTE. When the formatted portion of a SMBIOS structure references a string, it does so by specifying a non-zero string number within the structure's string-set. For example, if a string field contains 02h, it references the second string following the formatted portion of the SMBIOS structure. If a string field references no string, a null (0) is placed in that string field. If the formatted portion of the structure
contains string-reference fields and all the string fields are set to 0 (no string references), the formatted section of the structure is followed by two null (00h) BYTES. See 3.1.1 Structure Evolution and Usage Guidelines on page 29 for a string-containing example.

Note: Each text string is limited to 64 significant characters due to system MIF limitations.

3.2 Required Structures and Data

Beginning with SMBIOS v2.3, compliant SMBIOS implementations include the following base set of required structures and data within those structures. For a detailed list of conformance guidelines, refer to 4 Conformance Guidelines on page 94.

<table>
  <tr>
    <th>Structure Name and Type</th>
    <th>Data Requirements</th>
  </tr>
  <tr>
    <td>BIOS Information (Type 0)</td>
    <td>One and only one structure is present in the structure-table. <i>BIOS Version</i> and <i>BIOS Release Date</i> strings are non-null; the date field uses a 4-digit year (e.g. 1999). All other fields reflect full BIOS support information</td>
  </tr>
  <tr>
    <td>System Information (Type 1)</td>
    <td><i>Manufacturer</i> and <i>Product Name</i> strings are non-null. <i>UUID</i> field identifies the system’s non-zero UUID value. <i>Wake-up Type</i> field identifies the wake-up source and cannot be <b>Unknown</b>. One and only one structure is present in the structure-table.</td>
  </tr>
  <tr>
    <td>System Enclosure (Type 3)</td>
    <td><i>Manufacturer</i> string is non-null; the <i>Type</i> field identifies the type of enclosure (<b>Unknown</b> is disallowed).</td>
  </tr>
  <tr>
    <td>Processor Information (Type 4)</td>
    <td>One structure is required for each system processor. The presence of two structures with the <i>Processor Type</i> field set to <i>Central Processor</i>, for instance, identifies that the system is capable of dual-processor operations.<br><br><i>Socket Designation</i> string is non-null. <i>Processor Type</i>, <i>Max Speed</i>, and <i>Processor Upgrade</i> fields are all set to “known” values — i.e. the <b>Unknown</b> value is disallowed for each field.<br>If the associated processor is present (i.e. the <i>CPU Socket Populated</i> sub-field of the <i>Status</i> field indicates that the socket is populated), the <i>Processor Manufacturer</i> string is non-null and the <i>Processor Family</i>, <i>Current Speed</i>, and <i>CPU Status</i> sub-field of the <i>Status</i> field are all set to “known” values.<br><br>Each of the <i>Lx Cache Handle</i> fields is either set to 0xFFFF (no further cache description) or references a valid <i>Cache Information</i> Structure.</td>
  </tr>
  <tr>
    <td>Cache Information (Type 7)</td>
    <td>One structure is required for each external-to-the-processor cache.<br><br><i>Socket Designation</i> string is non-null if the cache is external to the processor. If the cache is present (i.e. the <i>Installed Size</i> is non-zero), the <i>Cache Configuration</i> field is set to a “known” value — i.e. the <b>Unknown</b> value is disallowed.</td>
  </tr>
  <tr>
    <td>System Slots (Type 9)</td>
    <td>One structure is required for each upgradeable system slot. A structure is not required if the slot must be populated for proper system operation (e.g. the system contains a single memory-card slot).<br><br><i>Slot Designation</i> string is non-null. <i>Slot Type</i>, <i>Slot Data Bus Width</i>, <i>Slot ID</i>, and <i>Slot Characteristics 1 & 2</i> are all set to “known” values.<br><br>If device presence is detectable within the slot (e.g. PCI), the <i>Current Usage</i> field must be set to either <i>Available</i> or <i>In-use</i>. Otherwise (e.g. ISA), the <b>Unknown</b> value for the field is also allowed.</td>
  </tr>
  <tr>
    <td>Physical Memory Array (Type 16)</td>
    <td>One structure is required for the system memory.<br><br><i>Location</i>, <i>Use</i>, <i>Memory Error Correction</i>, and <i>Maximum Capacity</i> are all set to “known” values. <i>Number of Memory Devices</i> is non-zero and identifies the number of <i>Memory Device</i> structures that are associated with this <i>Physical Memory Array</i>.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Structure Name and Type</th>
    <th>Data Requirements</th>
  </tr>
  <tr>
    <td>Memory Device (Type 17)</td>
    <td>One structure is required for each socketed system-memory device, whether or not the socket is currently populated; if the system includes soldered system-memory, one additional structure is required to identify that memory device.<br><i>Device Locator</i> string is set to a non-null value. <i>Memory Array Handle</i> contains the handle associated with the <i>Physical Memory Array</i> structure to which this device belongs. <i>Data Width</i>, <i>Size</i>, <i>Form Factor</i>, and <i>Device Set</i> are all set to “known” values. If the device is present (i.e. Size is non-zero), the <i>Total Width</i> field is not set to 0xFFFF (<i>Unknown</i>).</td>
  </tr>
  <tr>
    <td>Memory Array Mapped Address (Type 19)</td>
    <td>One structure is required for each contiguous block of memory addresses mapped to a <i>Physical Memory Array</i>.<br><i>Ending Address</i> is larger than <i>Starting Address</i>. Each structure’s address range is unique and non-overlapping. <i>Memory Array Handle</i> references a Physical Memory Array structure. <i>Partition Width</i> is non-zero.</td>
  </tr>
  <tr>
    <td>Memory Device Mapped Address (Type 20)</td>
    <td>Sufficient structures are required to map all enabled memory devices to their respective memory-array mapped addresses.<br><i>Ending Address</i> is larger than <i>Starting Address</i>. <i>Memory Device Handle</i> references a Memory Device structure. <i>Memory Mapped Address Handle</i> references a Memory Array Mapped Address structure. <i>Partition Row Position</i> is neither 0 nor 0xFF, nor is it greater than the <i>Partition Width</i> of the referenced Memory Array Mapped Address structure. <i>Interleave Position</i> and <i>Interleaved Data Depth</i> are not set to 0xFF (<i>Unknown</i>).</td>
  </tr>
  <tr>
    <td>System Boot Information (Type 32)</td>
    <td>The structure’s length is at least 0x0B, i.e. at least one byte of <i>System Boot Status</i> is provided</td>
  </tr>
</table>

3.3 Structure Definitions

Many of the enumerated values are shared between SMBIOS fields, Common Information Model (CIM) MOF properties, and DMI MASTER.MIF attributes. The table that follows identifies the relationships; any additions to these enumerated lists should be reflected in all three interfaces by submitting change requests to mailto://wg-sysdev@dmft.org and mailto://wg-dmi@dmft.org for the CIM-related and DMI/SMBIOS-related updates, respectively. Any other enumerated value identified in this specification is controlled by this specification; change requests should be sent to mailto://wg-dmi@dmft.org.

<table>
  <tr>
    <th>Name</th>
    <th>Section</th>
    <th>MOF File</th>
    <th>MOF Class.Property</th>
    <th>DMI Group|Attribute</th>
  </tr>
  <tr>
    <td>Baseboard</td>
    <td>3.3.3.1</td>
    <td>CIM_Physical</td>
    <td>CIM_PhysicalPackage.<br>HotSwappable<br>CIM_PhysicalPackage.Replaceable<br>CIM_PhysicalPackage.Removable<br>CIM_Card.<br>RequiresDaughterCard<br>CIM_Card.HostingBoard</td>
    <td>—</td>
  </tr>
  <tr>
    <td>Enclosure or Chassis Type</td>
    <td>3.3.4.1</td>
    <td>CIM_Physical</td>
    <td>CIM_Chassis.ChassisTypes</td>
    <td>System Enclosure|Enclosure or Chassis Type</td>
  </tr>
  <tr>
    <td>Enclosure or Chassis State</td>
    <td>3.3.4.2</td>
    <td>—</td>
    <td>—</td>
    <td>System Enclosure|Boot-up State<br>System Enclosure|Power State<br>System Enclosure|Thermal State</td>
  </tr>
  <tr>
    <td>Processor Type</td>
    <td>3.3.5.1</td>
    <td>—</td>
    <td>—</td>
    <td>Processor|Processor Type</td>
  </tr>
  <tr>
    <td>Processor Family</td>
    <td>3.3.5.2</td>
    <td>CIM_Device<br>CIM_Application</td>
    <td>CIM_Processor.Family<br>CIM_ArchitectureCheck.Architecture Type</td>
    <td>Processor|Processor Family</td>
  </tr>
  <tr>
    <td>Processor Upgrade</td>
    <td>3.3.5.5</td>
    <td>CIM_Device</td>
    <td>CIM_Processor.Upgrade Method</td>
    <td>Processor|Processor Upgrade</td>
  </tr>
  <tr>
    <td>Cache Error Correction Type</td>
    <td>3.3.8.2</td>
    <td>—</td>
    <td>—</td>
    <td>System Cache|System Cache Error Correction</td>
  </tr>
  <tr>
    <td>System Cache Type</td>
    <td>3.3.8.3</td>
    <td>CIM_Device</td>
    <td>CIM_CacheMemory.Cache Type</td>
    <td>System Cache|System Cache Type</td>
  </tr>
  <tr>
    <td>Cache Associativity</td>
    <td>3.3.8.4</td>
    <td>CIM_Device</td>
    <td>CIM_CacheMemory.Associativity</td>
    <td>System Cache|Associativity</td>
  </tr>
</table>
<table>
  <tr>
    <th>Name</th>
    <th>Section</th>
    <th>MOF File</th>
    <th>MOF Class.Property</th>
    <th>DMI Group/Attribute</th>
  </tr>
  <tr>
    <td>Slot Data Bus Width</td>
    <td>3.3.10.2</td>
    <td>CIM_Physical</td>
    <td>CIM_Slot.MaxDataWidth</td>
    <td>System Slots|Slot Width</td>
  </tr>
  <tr>
    <td>Slot Current Usage</td>
    <td>3.3.10.3</td>
    <td>CIM_Physical</td>
    <td>Note 1</td>
    <td>System Slots|Current Usage</td>
  </tr>
  <tr>
    <td>Memory Array Location</td>
    <td>3.3.17.1</td>
    <td>CIM_Device</td>
    <td>Note 2</td>
    <td>Physical Memory Array|Memory Array Location</td>
  </tr>
  <tr>
    <td>Memory Array Use</td>
    <td>3.3.17.2</td>
    <td>CIM_Device</td>
    <td>Note 3</td>
    <td>Physical Memory Array|Memory Array Use</td>
  </tr>
  <tr>
    <td>Memory Array Error Correction Types</td>
    <td>3.3.17.3</td>
    <td>CIM_Device</td>
    <td>CIM_Memory.ErrorMethodology (Note 4)</td>
    <td>Physical Memory Array|Memory Error Correction</td>
  </tr>
  <tr>
    <td>Memory Device Form Factor</td>
    <td>3.3.18.1</td>
    <td>CIM_Physical</td>
    <td>CIM_PhysicalMemory.FormFactor (Note 5)</td>
    <td>MemoryDevice|Form Factor</td>
  </tr>
  <tr>
    <td>Memory Device Type</td>
    <td>3.3.18.2</td>
    <td>CIM_Physical</td>
    <td>CIM_PhysicalMemory.MemoryType (Note 6)</td>
    <td>MemoryDevice|Memory Type</td>
  </tr>
  <tr>
    <td>Memory Device Type Detail</td>
    <td>3.3.18.3</td>
    <td>—</td>
    <td>—</td>
    <td>MemoryDevice|Type Detail</td>
  </tr>
  <tr>
    <td>Memory Error Type</td>
    <td>3.3.19.1</td>
    <td>CIM_Device</td>
    <td>CIM_Memory.ErrorInfo</td>
    <td>MemoryDevice|Device Error Type</td>
  </tr>
  <tr>
    <td>Memory Error Granularity</td>
    <td>3.3.19.2</td>
    <td>—</td>
    <td>—</td>
    <td>MemoryDevice|Error Granularity</td>
  </tr>
  <tr>
    <td>Memory Error Operation</td>
    <td>3.3.19.3</td>
    <td>CIM_Device</td>
    <td>CIM_Memory.ErrorAccess</td>
    <td>MemoryDevice|Error Operation</td>
  </tr>
  <tr>
    <td>Pointing Device Type</td>
    <td>3.3.22.1</td>
    <td>CIM_Device</td>
    <td>CIM_PointingDevice.PointingType</td>
    <td>Pointing Device|Pointing Device Type</td>
  </tr>
  <tr>
    <td>Pointing Device Interface</td>
    <td>3.3.22.2</td>
    <td>—</td>
    <td>—</td>
    <td>Pointing Device|Pointing Device Interface</td>
  </tr>
  <tr>
    <td>Portable Battery Device Chemistry</td>
    <td>3.3.23.1</td>
    <td>CIM_Device</td>
    <td>CIM_Battery.Chemistry</td>
    <td>Portable Battery|Portable Battery Device Chemistry</td>
  </tr>
  <tr>
    <td>Voltage or Current Probe Location</td>
    <td>3.3.27.1<br>3.3.30.1</td>
    <td>—</td>
    <td>—</td>
    <td>Voltage Probe|Voltage Probe Location<br>Electrical Current Probe|Electrical Current Probe Location</td>
  </tr>
  <tr>
    <td>Temperature Probe Location</td>
    <td>3.3.29.1</td>
    <td>—</td>
    <td>—</td>
    <td>Temperature Probe|Temperature Probe Location</td>
  </tr>
  <tr>
    <td>Voltage, Temperature, or Current Probe Status</td>
    <td>3.3.27.1<br>3.3.29.1</td>
    <td>—</td>
    <td>—</td>
    <td>Voltage Probe|Voltage Status<br>Temperature Probe|Temperature Status<br>Electrical Current Probe|Electrical Current Status</td>
  </tr>
  <tr>
    <td>Cooling Device Status</td>
    <td>3.3.30.1</td>
    <td>—</td>
    <td>—</td>
    <td>Operational State|Current Error Status</td>
  </tr>
  <tr>
    <td>Cooling Device Type</td>
    <td>3.3.28.1</td>
    <td>—</td>
    <td>—</td>
    <td>Cooling Device|Cooling Device Type</td>
  </tr>
  <tr>
    <td>Power Supply Type</td>
    <td>3.3.40.1</td>
    <td>—</td>
    <td>—</td>
    <td>Power Supply|Power Supply Type</td>
  </tr>
  <tr>
    <td>Power Supply Input Voltage Range Switching</td>
    <td>3.3.40.1</td>
    <td>CIM_Device</td>
    <td>CIM_PowerSupply.TypeOfRangeSwitching</td>
    <td>Power Supply|Input Voltage Range Switching</td>
  </tr>
</table>

Notes:

1. CIM handles slot population more explicitly than DMI, by using a CIM_CardInSlot class to associate the card (CIM_Card) with the slot (CIM_Slot) into which it is inserted.

2. CIM handles memory location more specifically than DMI, by using a CIM_AssociatedMemory class to associate the memory (CIM_Memory) with the device on which it is installed.

3. CIM handles memory array use more specifically than DMI, by defining classes that inherit from CIM_Memory to define the specific use — e.g. CIM_CacheMemory or CIM_NonVolatileStorage.

4. CIM maps memory error correction types into string values rather than enumerations.

5. CIM maps memory device form factor into string values rather than enumerations.

6. The CIM mapping of the SMBIOS memory type is not direct.
3.3.1 BIOS Information (Type 0)

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>0</td>
    <td>BIOS Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>12h + number of <i>BIOS Characteristics Extension</i> Bytes. If no Extension Bytes are used the Length will be 12h. For v2.1 and v2.2 implementations, the length is 13h since one extension byte is defined. For v2.3 and later implementations, the length is at least 14h since two extension bytes are defined. For v2.4 and later implementations, the length is at least 18h since bytes 14-17h are defined.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Vendor</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number of the BIOS Vendor’s Name</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>BIOS Version</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number of the BIOS Version. This is a free form string that may contain Core and OEM version information.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>BIOS Starting Address Segment</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Segment location of BIOS starting address, e.g.0E800h. Note: The size of the runtime BIOS image can be computed by subtracting the Starting Address Segment from 10000h and multiplying the result by 16.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>BIOS Release Date</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number of the BIOS release date. The date string, if supplied, is in either mm/dd/yy or mm/dd/yyyy format. If the year portion of the string is two digits, the year is assumed to be 19yy.<br><b>Note:</b> The mm/dd/yyyy format is required for SMBIOS version 2.3 and later.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>BIOS ROM Size</td>
    <td>BYTE</td>
    <td>Varies (n)</td>
    <td>Size (n) where 64K * (n+1) is the size of the physical device containing the BIOS, in bytes</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>BIOS Characteristics</td>
    <td>QWORD</td>
    <td>Bit Field</td>
    <td>Defines which functions the BIOS supports. PCI, PCMCIA, Flash, etc. See 3.3.1.1.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>BIOS Characteristics Extension Bytes</td>
    <td>Zero or more BYTES</td>
    <td>Bit Field</td>
    <td>Optional space reserved for future supported functions. The number of Extension Bytes that are present is indicated by the Length in offset 1 minus 12h. See 3.3.1.2 for extensions defined for v2.1 and later implementations. For version 2.4 and later implementations, two BIOS Characteristics Extension Bytes are defined (12-13h) and bytes 14-17h are also defined.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>System BIOS Major Release</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the major release of the System BIOS; for example, the value will be 0Ah for revision 10.22 and 02h for revision 2.1.<br>This field and/or the System BIOS Minor Release field will be updated each time a System BIOS update for a given system is released.<br>If the system does not support the use of this field, the value will be 0FFh for both this field and the System BIOS Minor Release field.</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>System BIOS Minor Release</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the minor release of the System BIOS; for example, the value will be 16h for revision 10.22 and 01h for revision 2.1.</td>
  </tr>
</table>
<table>
  <tr>
    <th>16h</th>
    <th>Embedded Controller Firmware Major Release</th>
    <th>BYTE</th>
    <th>Varies</th>
    <th>Identifies the major release of the embedded controller firmware; for example, the value will be 0Ah for revision 10.22 and 02h for revision 2.1.<br>This field and/or the Embedded Controller Firmware Minor Release field will be updated each time an embedded controller firmware update for a given system is released.<br>If the system does not have field upgradeable embedded controller firmware, the value will be 0FFh.</th>
  </tr>
  <tr>
    <th>17h</th>
    <th>Embedded Controller Firmware Minor Release</th>
    <th>BYTE</th>
    <th>Varies</th>
    <th>Identifies the minor release of the embedded controller firmware; for example, the value will be 16h for revision 10.22 and 01h for revision 2.1.<br>If the system does not have field upgradeable embedded controller firmware, the value will be 0FFh.</th>
  </tr>
</table>

3.3.1.1 BIOS Characteristics

<table>
  <tr>
    <th>QWORD Bit Position</th>
    <th>Meaning if Set</th>
  </tr>
  <tr><td>Bit 0</td><td>Reserved</td></tr>
  <tr><td>Bit 1</td><td>Reserved</td></tr>
  <tr><td>Bit 2</td><td>Unknown</td></tr>
  <tr><td>Bit 3</td><td>BIOS Characteristics Not Supported</td></tr>
  <tr><td>Bit 4</td><td>ISA is supported</td></tr>
  <tr><td>Bit 5</td><td>MCA is supported</td></tr>
  <tr><td>Bit 6</td><td>EISA is supported</td></tr>
  <tr><td>Bit 7</td><td>PCI is supported</td></tr>
  <tr><td>Bit 8</td><td>PC Card (PCMCIA) is supported</td></tr>
  <tr><td>Bit 9</td><td>Plug and Play is supported</td></tr>
  <tr><td>Bit 10</td><td>APM is supported</td></tr>
  <tr><td>Bit 11</td><td>BIOS is Upgradeable (Flash)</td></tr>
  <tr><td>Bit 12</td><td>BIOS shadowing is allowed</td></tr>
  <tr><td>Bit 13</td><td>VL-VESA is supported</td></tr>
  <tr><td>Bit 14</td><td>ESCD support is available</td></tr>
  <tr><td>Bit 15</td><td>Boot from CD is supported</td></tr>
  <tr><td>Bit 16</td><td>Selectable Boot is supported</td></tr>
  <tr><td>Bit 17</td><td>BIOS ROM is socketed</td></tr>
  <tr><td>Bit 18</td><td>Boot From PC Card (PCMCIA) is supported</td></tr>
  <tr><td>Bit 19</td><td>EDD (Enhanced Disk Drive) Specification is supported</td></tr>
  <tr><td>Bit 20</td><td>Int 13h - Japanese Floppy for NEC 9800 1.2mb (3.5", 1k Bytes/Sector, 360 RPM) is supported</td></tr>
  <tr><td>Bit 21</td><td>Int 13h - Japanese Floppy for Toshiba 1.2mb (3.5", 360 RPM) is supported</td></tr>
  <tr><td>Bit 22</td><td>Int 13h - 5.25"/360 KB Floppy Services are supported</td></tr>
  <tr><td>Bit 23</td><td>Int 13h - 5.25"/1.2MB Floppy Services are supported</td></tr>
  <tr><td>Bit 24</td><td>Int 13h - 3.5"/720 KB Floppy Services are supported</td></tr>
  <tr><td>Bit 25</td><td>Int 13h - 3.5"/2.88 MB Floppy Services are supported</td></tr>
  <tr><td>Bit 26</td><td>Int 5h, Print Screen Service is supported</td></tr>
  <tr><td>Bit 27</td><td>Int 9h, 8042 Keyboard services are supported</td></tr>
  <tr><td>Bit 28</td><td>Int 14h, Serial Services are supported</td></tr>
  <tr><td>Bit 29</td><td>Int 17h, Printer Services are supported</td></tr>
  <tr><td>Bit 30</td><td>Int 10h, CGA/Mono Video Services are supported</td></tr>
  <tr><td>Bit 31</td><td>NEC PC-98</td></tr>
  <tr><td>Bits32:47</td><td>Reserved for BIOS Vendor</td></tr>
  <tr><td>Bits 48:63</td><td>Reserved for System Vendor</td></tr>
</table>

3.3.1.2 BIOS Characteristics Extension Bytes

Note: All Characteristics Extension Bytes are reserved for assignment via this specification.
3.3.1.2.1 BIOS Characteristics Extension Byte 1

This information, available for SMBIOS version 2.1 and later, appears at offset 12h within the BIOS Information structure.

<table>
  <tr>
    <th>Byte Bit Position</th>
    <th>Meaning if Set</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>ACPI supported</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>USB Legacy is supported</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>AGP is supported</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>I2O boot is supported</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>LS-120 boot is supported</td>
  </tr>
  <tr>
    <td>Bit 5</td>
    <td>ATAPI ZIP Drive boot is supported</td>
  </tr>
  <tr>
    <td>Bit 6</td>
    <td>1394 boot is supported</td>
  </tr>
  <tr>
    <td>Bit 7</td>
    <td>Smart Battery supported</td>
  </tr>
</table>

3.3.1.2.2 BIOS Characteristics Extension Byte 2

This information, available for SMBIOS version 2.3 and later, appears at offset 13h within the BIOS Information structure.

<table>
  <tr>
    <th>Byte Bit Position</th>
    <th>Meaning if Set</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>BIOS Boot Specification supported</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Function key-initiated Network Service boot supported. When function key-uninitiated Network Service Boot is not supported, a network adapter option ROM may choose to offer this functionality on its own, thus offering this capability to legacy systems. When the function is supported, the network adapter option ROM shall not offer this capability.</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>Enable Targeted Content Distribution. The manufacturer has ensured that the SMBIOS data is useful in identifying the computer for targeted delivery of model-specific software and firmware content through third-party content distribution services.</td>
  </tr>
  <tr>
    <td>Bits 3:7</td>
    <td>Reserved for future assignment via this specification.</td>
  </tr>
</table>

3.3.2 System Information (Type 1)

The information in this structure defines attributes of the overall system and is intended to be associated with the Component ID group of the system’s MIF. An SMBIOS implementation is associated with a single system instance and contains one and only one System Information (Type 1) structure.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>1</td>
    <td>System Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>08h or 19h</td>
    <td>Length dependent on version supported, 08h for 2.0 or 19h for 2.1-2.3.4, 1Bh for 2.4 and later.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.0+</td>
    <td>Product Name</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Version</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.0+</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.1+</td>
    <td>UUID</td>
    <td>16 BYTES</td>
    <td>Varies</td>
    <td>Universal Unique ID number. If the value is all FFh, the ID is not currently present in the system, but is settable. If the value is all 00h, the ID is not present in the system.</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>2.1+</td>
    <td>Wake-up Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the event that caused the system to power up. See 3.3.2.1.</td>
  </tr>
</table>
<table>
  <tr>
    <th>19h</th>
    <th>2.4+</th>
    <th>SKU Number</th>
    <th>BYTE</th>
    <th>STRING</th>
    <th>Number of Null terminated string.<br>This text string is used to identify a particular computer configuration for sale. It is sometimes also called a product ID or purchase order number. This number is frequently found in existing fields, but there is no standard format. Typically for a given system board from a given OEM, there are tens of unique processor, memory, hard drive, and optical drive configurations.</th>
  </tr>
  <tr>
    <th>1Ah</th>
    <th>2.4+</th>
    <th>Family</th>
    <th>BYTE</th>
    <th>STRING</th>
    <th>Number of Null terminated string.<br>This text string is used to identify the family a particular computer belongs to. A family refers to a set of computers that are similar but not identical from a hardware or software point of view. Typically, a family is composed of different computer models, which have different configurations and pricing points. Computers in the same family often have similar branding and cosmetic features.</th>
  </tr>
</table>

3.3.2.1 System — Wake-up Type

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Reserved</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>APM Timer</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Modem Ring</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>LAN Remote</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Power Switch</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>PCI PME#</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>AC Power Restored</td>
  </tr>
</table>

3.3.3 Base Board (or Module) Information (Type 2)

The information in this structure defines attributes of a system baseboard — for example a motherboard, planar, or server blade or other standard system module.

Note: If more than one Type 2 structure is provided by an SMBIOS implementation, each structure shall include the Number of Contained Object Handles and Contained Object Handles fields to specify which system elements are contained on which boards. If a single Type 2 structure is provided and the contained object information is not present¹, or if no Type 2 structure is provided then all system elements identified by the SMBIOS implementation are associated with a single motherboard.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>2</td>
    <td>Base Board Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, at least 08h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Product</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Version</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
</table>

¹ This information is "not present" if either the Length of the Type 2 structure is less than 14 (0EH) or if the Number of Contained Object Handles field at offset 0Dh is set to 0.
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>07h</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Asset Tag</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of a null-terminated string.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Feature Flags</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>A collection of flags that identify features of this baseboard. See 3.3.3.1.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Location in Chassis</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of a null-terminated string that describes this board's location within the chassis referenced by the Chassis Handle below.<br><br><b>Note:</b> This field supports a CIM_Container class mapping where:<br>LocationWithinContainer is this field<br>GroupComponent is the chassis referenced by <i>Chassis Handle</i><br>PartComponent is this baseboard</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Chassis Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the chassis in which this board resides (see System Enclosure or Chassis (Type 3) on page 39).</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Board Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the type of board; see 3.3.3.2.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Number of Contained Object Handles (\( n \))</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the number (0 to 255) of Contained Object Handles that follow.</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>Contained Object Handles</td>
    <td>\( n \) WORDs</td>
    <td>Varies</td>
    <td>A list of handles of other structures (e.g. Base Board, Processor, Port, System Slots, Memory Device) that are contained by this baseboard.</td>
  </tr>
</table>

3.3.3.1 Base Board — Feature Flags

<b>Important Note:</b> Refer to 3.3 for the CIM and DMI attributes associated with these bit fields.

<table>
  <tr>
    <th>Bit Position(s)</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>7:5</td>
    <td>Reserved for future definition by this specification, set to 000b.</td>
  </tr>
  <tr>
    <td>4</td>
    <td>Set to 1 if the board is hot swappable; it is possible to replace the board with a physically different but equivalent one while power is applied to the board. The board is inherently replaceable and removable.</td>
  </tr>
  <tr>
    <td>3</td>
    <td>Set to 1 if the board is replaceable; it is possible to replace (either as a field repair or upgrade) the board with a physically different one. The board is inherently removable.</td>
  </tr>
  <tr>
    <td>2</td>
    <td>Set to 1 if the board is removable; it is designed to be taken in and out of the chassis without impairing the function of the chassis</td>
  </tr>
  <tr>
    <td>1</td>
    <td>Set to 1 if the board requires at least one daughter board or auxiliary card to function properly.</td>
  </tr>
  <tr>
    <td>0</td>
    <td>Set to 1 if the board is a hosting board, e.g. a motherboard.</td>
  </tr>
</table>

3.3.3.2 Base Board — Board Type

<b>Note:</b> These enumerations are also used within the System Enclosure or Chassis (Type 3) structure's Contained Element record.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Server Blade</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Connectivity Switch</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>System Management Module</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Processor Module</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>I/O Module</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Memory Module</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>09h</td>
    <td>Daughter board</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Motherboard (includes processor, memory, and I/O)</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Processor/Memory Module</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Processor/I/O Module</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Interconnect Board</td>
  </tr>
</table>

3.3.4 System Enclosure or Chassis (Type 3)

The information in this structure defines attributes of the system’s mechanical enclosure(s). For example, if a system included a separate enclosure for its peripheral devices, two structures would be returned: one for the main, system enclosure and the second for the peripheral device enclosure. The additions to this structure in v2.1 of this specification support the population of the DMI Physical Container Global Table group or a CIM_Chassis class.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>3</td>
    <td>System Enclosure Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>09h for v2.0 implementations or a minimum of 0Dh for v2.1 and later implementations.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Bit 7 Chassis lock present if 1. Otherwise, either a lock is not present or it is unknown if the enclosure has a lock. Bits 6:0 Enumeration value, see below.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Version</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.0+</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.0+</td>
    <td>Asset Tag Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Number of Null terminated string</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>2.1+</td>
    <td>Boot-up State</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the state of the enclosure when it was last booted. See 3.3.4.2 for definitions.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>2.1+</td>
    <td>Power Supply State</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the state of the enclosure’s power supply (or supplies) when last booted. See 3.3.4.2 for definitions.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.1+</td>
    <td>Thermal State</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the enclosure’s thermal state when last booted. See 3.3.4.2 for definitions.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.1+</td>
    <td>Security Status</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the enclosure’s physical security status when last booted.. See 3.3.4.3 for definitions.</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>2.3+</td>
    <td>OEM-defined</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>Contains OEM- or BIOS vendor-specific information.</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>2.3+</td>
    <td>Height</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The height of the enclosure, in 'U's. A U is a standard unit of measure for the height of a rack or rack-mountable component and is equal to 1.75 inches or 4.445 cm. A value of 00h indicates that the enclosure height is unspecified.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>2.3+</td>
    <td>Number of Power Cords</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the number of power cords associated with the enclosure or chassis. A value of 00h indicates that the number is unspecified.</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>2.3+</td>
    <td>Contained Element Count (\( n \))</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the number of Contained Element records that follow, in the range 0 to 255. Each Contained Element group comprises \( m \) bytes, as specified by the Contained Element Record Length field that follows. If no Contained Elements are included, this field is set to 0.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>14h</td>
    <td>2.3+</td>
    <td>Contained Element Record Length (\( m \))</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the byte length of each Contained Element record that follow, in the range 0 to 255. If no Contained Elements are included, this field is set to 0. For v2.3.2 and later of this specification, this field is set to at least 03h when Contained Elements are specified.</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>2.3+</td>
    <td>Contained Elements</td>
    <td>\( n * m \) BYTES</td>
    <td>Varies</td>
    <td>Identifies the elements, possibly defined by other SMBIOS structures, present in this chassis. See 3.3.4.4 for definitions.</td>
  </tr>
</table>

3.3.4.1 System Enclosure or Chassis Types

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Desktop</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Low Profile Desktop</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Pizza Box</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Mini Tower</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Tower</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Portable</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>LapTop</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Notebook</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Hand Held</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Docking Station</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>All in One</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Sub Notebook</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>Space-saving</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>Lunch Box</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>Main Server Chassis</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>Expansion Chassis</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>SubChassis</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>Bus Expansion Chassis</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>Peripheral Chassis</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>RAID Chassis</td>
  </tr>
  <tr>
    <td>17h</td>
    <td>Rack Mount Chassis</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>Sealed-case PC</td>
  </tr>
  <tr>
    <td>19h</td>
    <td>Multi-system chassis. When this value is specified by an SMBIOS implementation, the physical chassis associated with this structure supports multiple, independently reporting physical systems — regardless of the chassis' current configuration. Systems in the same physical chassis are required to report the same value in this structure's Serial Number field.<br><br>For a chassis that may also be configured as either a single system or multiple physical systems, the Multi-system chassis value is reported even if the chassis is currently configured as a single system. This allows management applications to recognize the multi-system potential of the chassis.</td>
  </tr>
</table>

3.3.4.2 System Enclosure or Chassis States

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Safe</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Warning</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Critical</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Non-recoverable</td>
  </tr>
</table>

3.3.4.3 System Enclosure or Chassis Security Status

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>External interface locked out</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>External interface enabled</td>
  </tr>
</table>

3.3.4.4 System Enclosure or Chassis: Contained Elements

Each Contained Element record consists of sub-fields that further describe elements contained by the chassis. Relative offset and size of fields within each record shall remain the same in future revisions to this specification, but new fields might be added to the end of the current definitions.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.3+</td>
    <td>Contained Element Type</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>Specifies the type of element associated with this record.<br><br>Bit(s) | Meaning<br>7 | Type Select. Identifies whether the Type contains an SMBIOS structure type enumeration (1) or an SMBIOS Base Board Type enumeration (0).<br>6:0 | Type. The value specifies either an SMBIOS Board Type enumeration (see 3.3.3.2 for definitions) or an SMBIOS structure type, dependent on the setting of the Type Select.<br><br>For example, a contained Power Supply is specified as A7h (1 0100111b) — the MSB is 1, so the remaining seven bits (27h = 39) represent an SMBIOS structure type; structure type 39 represents a System Power Supply. A contained Server Blade is specified as 03h — the MSB is 0, so the remaining seven bits represent an SMBIOS Board Type; board type 03h represents a Server Blade.</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.3+</td>
    <td>Contained Element Minimum</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Specifies the minimum number of the element type that can be installed in the chassis for the chassis to properly operate, in the range 0 to 254. The value 255 (OFFh) is reserved for future definition by this specification.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.3+</td>
    <td>Contained Element Maximum</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Specifies the maximum number of the element type that can be installed in the chassis, in the range 1 to 255. The value 0 is reserved for future definition by this specification.</td>
  </tr>
</table>
3.3.5 Processor Information (Type 4)

The information in this structure defines the attributes of a single processor; a separate structure instance is provided for each system processor socket/slot. For example, a system with an IntelDX2™ processor would have a single structure instance while a system with an IntelSX2™ processor would have a structure to describe the main CPU and a second structure to describe the 80487 co-processor.

Note: One structure is provided for each processor instance in a system. For example, a system that supports up to two processors includes two Processor Information structures — even if only one processor is currently installed. Software that interprets the SMBIOS information can count the Processor Information structures to determine the maximum possible configuration of the system.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>4</td>
    <td>Processor Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The Length is 1Ah for v2.0 implementations or a minimum of 20h for v2.1 and later implementations.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Socket Designation</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for Reference Designation. Example string 'J202', 0</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.0+</td>
    <td>Processor Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.5.1 on page 43</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Processor Family</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.5.2 on page 44</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.0+</td>
    <td>Processor Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number of Processor Manufacturer</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.0+</td>
    <td>Processor ID</td>
    <td>QWORD</td>
    <td>Varies</td>
    <td>Raw processor identification data. See 3.3.5.3 for details.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>2.0+</td>
    <td>Processor Version</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number describing the Processor</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>2.0+</td>
    <td>Voltage</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>See 3.3.5.4.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>2.0+</td>
    <td>External Clock</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>External Clock Frequency, in MHz. If the value is unknown, the field is set to 0.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>2.0+</td>
    <td>Max Speed</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Maximum processor speed (in MHz) supported by the system for this processor socket. 0E9h for a 233MHz processor. If the value is unknown, the field is set to 0.<br><br><i>Note:</i> This field identifies a capability for the system, not the processor itself.<br><br>Same format as Max Speed.</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>2.0+</td>
    <td>Current Speed</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>This field identifies the processor's speed at system boot and the Processor ID field implies the processor's additional speed characteristics (i.e. single speed or multiple speed).</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>18h</td>
    <td>2.0+</td>
    <td>Status</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Bit 7 Reserved, must be 0<br>Bit 6 CPU Socket Populated<br>1 - CPU Socket Populated<br>0 - CPU Socket Unpopulated<br>Bits 5:3 Reserved, must be zero<br>Bits 2:0 CPU Status<br>0h - Unknown<br>1h - CPU Enabled<br>2h - CPU Disabled by User via BIOS Setup<br>3h - CPU Disabled By BIOS (POST Error)<br>4h - CPU is Idle, waiting to be enabled.<br>5-6h - Reserved<br>7h - Other</td>
  </tr>
  <tr>
    <td>19h</td>
    <td>2.0+</td>
    <td>Processor Upgrade</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.5.5</td>
  </tr>
  <tr>
    <td>1Ah</td>
    <td>2.1+</td>
    <td>L1 Cache Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle of a Cache Information structure that defines the attributes of the primary (Level 1) cache for this processor. For v2.1 and v2.2 implementations, the value is 0FFFFh if the processor has no L1 cache. For v2.3 and later implementations, the value is 0FFFFh if the Cache Information structure is not provided.<sup>2</sup></td>
  </tr>
  <tr>
    <td>1Ch</td>
    <td>2.1+</td>
    <td>L2 Cache Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle of a Cache Information structure that defines the attributes of the secondary (Level 2) cache for this processor. For v2.1 and v2.2 implementations, the value is 0FFFFh if the processor has no L2 cache. For v2.3 and later implementations, the value is 0FFFFh if the Cache Information structure is not provided.<sup>2</sup></td>
  </tr>
  <tr>
    <td>1Eh</td>
    <td>2.1+</td>
    <td>L3 Cache Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle of a Cache Information structure that defines the attributes of the tertiary (Level 3) cache for this processor. For v2.1 and v2.2 implementations, the value is 0FFFFh if the processor has no L3 cache. For v2.3 and later implementations, the value is 0FFFFh if the Cache Information structure is not provided.<sup>2</sup></td>
  </tr>
  <tr>
    <td>20h</td>
    <td>2.3+</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the serial number of this processor. This value is set by the manufacturer and normally not changeable.</td>
  </tr>
  <tr>
    <td>21h</td>
    <td>2.3+</td>
    <td>Asset Tag</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the asset tag of this processor.</td>
  </tr>
  <tr>
    <td>22h</td>
    <td>2.3+</td>
    <td>Part Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the part number of this processor. This value is set by the manufacturer and normally not changeable.</td>
  </tr>
</table>

3.3.5.1 Processor Information - Processor Type

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

2 Beginning with v2.3 implementations, if the Cache Handle is 0FFFFh, management software must make no assumptions about the cache's attributes and should report all cache-related attributes as unknown. The definitive absence of a specific cache is identified by referencing a Cache Information structure and setting that structure's Installed Size field to 0.
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Central Processor</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Math Processor</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>DSP Processor</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Video Processor</td>
  </tr>
</table>

3.3.5.2 Processor Information - Processor Family

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>8086</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>80286</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Intel386™ processor</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Intel486™ processor</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>8087</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>80287</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>80387</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>80487</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Pentium® processor Family</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Pentium® Pro processor</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Pentium® II processor</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Pentium® processor with MMX™ technology</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>Celeron™ processor</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>Pentium® II Xeon™ processor</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>Pentium® III processor</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>M1 Family</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>M2 Family</td>
  </tr>
  <tr>
    <td>14h-17h</td>
    <td>Available for assignment</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>AMD Duron™ Processor Family</td>
  </tr>
  <tr>
    <td>19h</td>
    <td>K5 Family</td>
  </tr>
  <tr>
    <td>1Ah</td>
    <td>K6 Family</td>
  </tr>
  <tr>
    <td>1Bh</td>
    <td>K6-2</td>
  </tr>
  <tr>
    <td>1Ch</td>
    <td>K6-3</td>
  </tr>
  <tr>
    <td>1Dh</td>
    <td>AMD Athlon™ Processor Family</td>
  </tr>
  <tr>
    <td>1Eh</td>
    <td>AMD2900 Family</td>
  </tr>
  <tr>
    <td>1Fh</td>
    <td>K6-2+</td>
  </tr>
  <tr>
    <td>20h</td>
    <td>Power PC Family</td>
  </tr>
  <tr>
    <td>21h</td>
    <td>Power PC 601</td>
  </tr>
  <tr>
    <td>22h</td>
    <td>Power PC 603</td>
  </tr>
  <tr>
    <td>23h</td>
    <td>Power PC 603+</td>
  </tr>
  <tr>
    <td>24h</td>
    <td>Power PC 604</td>
  </tr>
  <tr>
    <td>25h</td>
    <td>Power PC 620</td>
  </tr>
  <tr>
    <td>26h</td>
    <td>Power PC x704</td>
  </tr>
  <tr>
    <td>27h</td>
    <td>Power PC 750</td>
  </tr>
  <tr>
    <td>28h-2Fh</td>
    <td>Available for assignment</td>
  </tr>
  <tr>
    <td>30h</td>
    <td>Alpha Family<sup>3</sup></td>
  </tr>
  <tr>
    <td>31h</td>
    <td>Alpha 21064</td>
  </tr>
</table>

3 Some v2.0 specification implementations used Processor Family type value 30h to represent a Pentium ® Pro processor.
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>32h</td>
    <td>Alpha 21066</td>
  </tr>
  <tr>
    <td>33h</td>
    <td>Alpha 21164</td>
  </tr>
  <tr>
    <td>34h</td>
    <td>Alpha 21164PC</td>
  </tr>
  <tr>
    <td>35h</td>
    <td>Alpha 21164a</td>
  </tr>
  <tr>
    <td>36h</td>
    <td>Alpha 21264</td>
  </tr>
  <tr>
    <td>37h</td>
    <td>Alpha 21364</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">38h-3Fh Available for assignment</td>
  </tr>
  <tr>
    <td>40h</td>
    <td>MIPS Family</td>
  </tr>
  <tr>
    <td>41h</td>
    <td>MIPS R4000</td>
  </tr>
  <tr>
    <td>42h</td>
    <td>MIPS R4200</td>
  </tr>
  <tr>
    <td>43h</td>
    <td>MIPS R4400</td>
  </tr>
  <tr>
    <td>44h</td>
    <td>MIPS R4600</td>
  </tr>
  <tr>
    <td>45h</td>
    <td>MIPS R10000</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">46h-4Fh Available for assignment</td>
  </tr>
  <tr>
    <td>50h</td>
    <td>SPARC Family</td>
  </tr>
  <tr>
    <td>51h</td>
    <td>SuperSPARC</td>
  </tr>
  <tr>
    <td>52h</td>
    <td>microSPARC II</td>
  </tr>
  <tr>
    <td>53h</td>
    <td>microSPARC IleP</td>
  </tr>
  <tr>
    <td>54h</td>
    <td>UltraSPARC</td>
  </tr>
  <tr>
    <td>55h</td>
    <td>UltraSPARC II</td>
  </tr>
  <tr>
    <td>56h</td>
    <td>UltraSPARC III</td>
  </tr>
  <tr>
    <td>57h</td>
    <td>UltraSPARC IIIi</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">59h-5Fh Available for assignment</td>
  </tr>
  <tr>
    <td>60h</td>
    <td>68040 Family</td>
  </tr>
  <tr>
    <td>61h</td>
    <td>68xxx</td>
  </tr>
  <tr>
    <td>62h</td>
    <td>68000</td>
  </tr>
  <tr>
    <td>63h</td>
    <td>68010</td>
  </tr>
  <tr>
    <td>64h</td>
    <td>68020</td>
  </tr>
  <tr>
    <td>65h</td>
    <td>68030</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">66h-6Fh Available for assignment</td>
  </tr>
  <tr>
    <td>70h</td>
    <td>Hobbit Family</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">71h-77h Available for assignment</td>
  </tr>
  <tr>
    <td>78h</td>
    <td>Crusoe™ TM5000 Family</td>
  </tr>
  <tr>
    <td>79h</td>
    <td>Crusoe™ TM3000 Family</td>
  </tr>
  <tr>
    <td>7Ah</td>
    <td>Efficeon™ TM8000 Family</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">7Bh-7Fh Available for assignment</td>
  </tr>
  <tr>
    <td>80h</td>
    <td>Weitek</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">81h Available for assignment</td>
  </tr>
  <tr>
    <td>82h</td>
    <td>Itanium™ processor</td>
  </tr>
  <tr>
    <td>83h</td>
    <td>AMD Athlon™ 64 Processor Family</td>
  </tr>
  <tr>
    <td>84h</td>
    <td>AMD Opteron™ Processor Family</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">85h-8Fh Available for assignment</td>
  </tr>
  <tr>
    <td>90h</td>
    <td>PA-RISC Family</td>
  </tr>
  <tr>
    <td>91h</td>
    <td>PA-RISC 8500</td>
  </tr>
  <tr>
    <td>92h</td>
    <td>PA-RISC 8000</td>
  </tr>
  <tr>
    <td>93h</td>
    <td>PA-RISC 7300LC</td>
  </tr>
  <tr>
    <td>94h</td>
    <td>PA-RISC 7200</td>
  </tr>
  <tr>
    <td>95h</td>
    <td>PA-RISC 7100LC</td>
  </tr>
  <tr>
    <td>96h</td>
    <td>PA-RISC 7100</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">97h-9Fh Available for assignment</td>
  </tr>
  <tr>
    <td>A0h</td>
    <td>V30 Family</td>
  </tr>
  <tr>
    <td colspan="2" style="background-color:#cccccc;">A1h-AFh Available for assignment</td>
  </tr>
  <tr>
    <td>B0h</td>
    <td>Pentium® III Xeon™ processor</td>
  </tr>
  <tr>
    <td>B1h</td>
    <td>Pentium® III Processor with Intel® SpeedStep™ Technology</td>
  </tr>
  <tr>
    <td>B2h</td>
    <td>Pentium® 4 Processor</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>B3h</td>
    <td>Intel® Xeon™</td>
  </tr>
  <tr>
    <td>B4h</td>
    <td>AS400 Family</td>
  </tr>
  <tr>
    <td>B5h</td>
    <td>Intel® Xeon™ processor MP</td>
  </tr>
  <tr>
    <td>B6h</td>
    <td>AMD Athlon™ XP Processor Family</td>
  </tr>
  <tr>
    <td>B7h</td>
    <td>AMD Athlon™ MP Processor Family</td>
  </tr>
  <tr>
    <td>B8h</td>
    <td>Intel® Itanium® 2 processor</td>
  </tr>
  <tr>
    <td>B9h</td>
    <td>Intel® Pentium® M processor</td>
  </tr>
  <tr>
    <td>BAh-C7h</td>
    <td>Available for assignment</td>
  </tr>
  <tr>
    <td>C8h</td>
    <td>IBM390 Family</td>
  </tr>
  <tr>
    <td>C9h</td>
    <td>G4</td>
  </tr>
  <tr>
    <td>CAh</td>
    <td>G5</td>
  </tr>
  <tr>
    <td>CBh-F9h</td>
    <td>Available for assignment</td>
  </tr>
  <tr>
    <td>FAh</td>
    <td>i860</td>
  </tr>
  <tr>
    <td>FBh</td>
    <td>i960</td>
  </tr>
  <tr>
    <td>FCh-FFh</td>
    <td>Available for assignment</td>
  </tr>
</table>

3.3.5.3 Processor ID Field Format

The Processor ID field contains processor-specific information that describes the processor’s features.

3.3.5.3.1 X86-Class CPUs

For x86 class CPUs, the field’s format depends on the processor’s support of the CPUID instruction. If the instruction is supported, the Processor ID field contains two DWORD-formatted values. The first (offsets 08h-0Bh) is the EAX value returned by a CPUID instruction with input EAX set to 1; the second (offsets 0Ch-0Fh) is the EDX value returned by that instruction.

Otherwise, only the first two bytes of the Processor ID field are significant (all others are set to 0) and contain (in WORD-format) the contents of the DX register at CPU reset.

3.3.5.4 Processor Information – Voltage

Two forms of information can be specified by the SMBIOS in this field, dependent on the value present in bit 7 (the most-significant bit). If bit 7 is 0 (legacy mode), the remaining bits of the field represent the specific voltages that the processor socket can accept, as follows:

Bit 7    Set to 0, indicating ‘legacy’ mode for processor voltage
Bits 6:4 Reserved, must be zero
Bits 3:0 Voltage Capability. A Set bit indicates that the voltage is supported.
    Bit 0 - 5V
    Bit 1 - 3.3V
    Bit 2 - 2.9V
    Bit 3 - Reserved, must be zero.
    Note: Setting of multiple bits indicates the socket is configurable

If bit 7 is set to 1, the remaining seven bits of the field are set to contain the processor’s current voltage times 10. For example, the field value for a processor voltage of 1.8 volts would be 92h = 80h + (1.8 * 10) = 80h + 18 = 80h +12h.

3.3.5.5 Processor Information - Processor Upgrade

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Daughter Board</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>ZIF Socket</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Replaceable Piggy Back</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>LIF Socket</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Slot 1</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Slot 2</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>370-pin socket</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Slot A</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Slot M</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Socket 423</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Socket A (Socket 462)</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>Socket 478</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>Socket 754</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>Socket 940</td>
  </tr>
</table>

3.3.6 Memory Controller Information (Type 5)

The information in this structure defines the attributes of the system’s memory controller(s) and the supported attributes of any memory-modules present in the sockets controlled by this controller.

Note: This structure, and its companion Memory Module Information (Type 6), are obsolete starting with version 2.1 of this specification; the Physical Memory Array (Type 16) and Memory Device (Type 17) structures should be used instead to allow proper population of the DMI 2.0 required groups. BIOS providers might choose to implement both memory description types to allow existing DMI browsers to properly display the system’s memory attributes.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>5</td>
    <td>Memory Controller Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Computed by the BIOS as either 15 + (2 * x) for v2.0 implementations or 16 + (2 * x) for v2.1 and later implementations, where x is the value present in offset 0Eh.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Error Detecting Method</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.6.1</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.0+</td>
    <td>Error Correcting Capability</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>See 3.3.6.2</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Supported Interleave</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.6.3</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.0+</td>
    <td>Current Interleave</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.6.3</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.0+</td>
    <td>Maximum Memory Module Size</td>
    <td>BYTE</td>
    <td>Varies (n)</td>
    <td>The size of the largest memory module supported (per slot), specified as n, where 2**n is the maximum size in MB. The maximum amount of memory supported by this controller is that value times the number of slots, as specified in offset 0Eh of this structure.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>2.0+</td>
    <td>Supported Speeds</td>
    <td>WORD</td>
    <td>Bit Field</td>
    <td>See 3.3.6.4 for bit-wise descriptions.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.0+</td>
    <td>Supported Memory Types</td>
    <td>WORD</td>
    <td>Bit Field</td>
    <td>See 3.3.7.1 on page 50 for bit-wise descriptions.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>2.0+</td>
    <td>Memory Module Voltage</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>This field describes the required voltages for each of the memory module sockets controlled by this controller:<br>Bits 7:3 Reserved, must be zero<br>Bit 2 2.9V<br>Bit 1 3.3V<br>Bit 0 5V<br>Note: Setting of multiple bits indicates the sockets are configurable</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>2.0+</td>
    <td>Number of Associated Memory Slots (x)</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Defines how many of the <i>Memory Module Information</i> blocks are controlled by this controller.</td>
  </tr>
  <tr>
    <td>0Fh to 0Fh + (2^x) - 1</td>
    <td>2.0+</td>
    <td>Memory Module Configuration Handles</td>
    <td>x WORDs</td>
    <td>Varies</td>
    <td>A list of memory information structure handles controlled by this controller. Value in offset 0Eh (x) defines the count.</td>
  </tr>
  <tr>
    <td>0Fh + (2^x)</td>
    <td>2.1+</td>
    <td>Enabled Error Correcting Capabilities</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>Identifies the error-correcting capabilities that were enabled when the structure was built. See 3.3.6.2 for bit-wise definitions.</td>
  </tr>
</table>

3.3.6.1 Memory Controller Error Detecting Method

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>8-bit Parity</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>32-bit ECC</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>64-bit ECC</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>128-bit ECC</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>CRC</td>
  </tr>
</table>

3.3.6.2 Memory Controller Error Correcting Capability

<table>
  <tr>
    <th>Byte Bit Position</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>None</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>Single Bit Error Correcting</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>Double Bit Error Correcting</td>
  </tr>
  <tr>
    <td>Bit 5</td>
    <td>Error Scrubbing</td>
  </tr>
</table>

3.3.6.3 Memory Controller Information - Interleave Support

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>One Way Interleave</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Two Way Interleave</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Four Way Interleave</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Eight Way Interleave</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Sixteen Way Interleave</td>
  </tr>
</table>
3.3.6.4 Memory Controller Information - Memory Speeds

This bit-field describes the speed of the memory modules supported by the system.

<table>
  <tr>
    <th>Word Bit Position</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>70ns</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>60ns</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>50ns</td>
  </tr>
  <tr>
    <td>Bits 5:15</td>
    <td>Reserved, must be zero</td>
  </tr>
</table>

3.3.7 Memory Module Information (Type 6)

One Memory Module Information structure is included for each memory-module socket in the system. The structure describes the speed, type, size, and error status of each system memory module. The supported attributes of each module are described by the “owning” Memory Controller Information structure.

Note: This structure, and its companion Memory Controller Information (Type 5), are obsolete starting with version 2.1 of this specification; the Physical Memory Array (Type 16) and Memory Device (Type 17) structures should be used instead to allow proper population of the DMI 2.0 required groups. BIOS providers might choose to implement both memory description types to allow existing DMI browsers to properly display the system’s memory attributes.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>6</td>
    <td>Memory Module Configuration Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>0Ch</td>
    <td></td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Socket Designation</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String Number for Reference Designation. Example 'J202',0</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Bank Connections</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Each nibble indicates a bank (RAS#) connection, 0xF means no connection. Example: If banks 1 & 3 (RAS# 1 & 3) were connected to a SIMM socket the byte for that socket would be 13h. If only bank 2 (RAS 2) were connected the byte for that socket would be 2Fh.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Current Speed</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The speed of the memory module, in ns (e.g. 70d for a 70ns module). If the speed is unknown, the field is set to 0.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Current Memory Type</td>
    <td>WORD</td>
    <td>Bit Field</td>
    <td>See 3.3.7.1</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Installed Size</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>See 3.3.7.2</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Enabled Size</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>See 3.3.7.2</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Error Status</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Bits 7:3 Reserved, set to 0's<br>Bit 2 If set, the Error Status information should be obtained from the event log; bits 1and 0 are reserved.<br>Bit 1 Correctable errors received for the module, if set. This bit will only be reset during a system reset.<br>Bit 0 Uncorrectable errors received for the module, if set. All or a portion of the module has been disabled. This bit is only reset on power-on.</td>
  </tr>
</table>
3.3.7.1 Memory Module Information - Memory Types

This bit-field describes the physical characteristics of the memory modules that are supported by (and currently installed in) the system.

<table>
  <tr>
    <th>Word Bit Position</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>Standard</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>Fast Page Mode</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>EDO</td>
  </tr>
  <tr>
    <td>Bit 5</td>
    <td>Parity</td>
  </tr>
  <tr>
    <td>Bit 6</td>
    <td>ECC</td>
  </tr>
  <tr>
    <td>Bit 7</td>
    <td>SIMM</td>
  </tr>
  <tr>
    <td>Bit 8</td>
    <td>DIMM</td>
  </tr>
  <tr>
    <td>Bit 9</td>
    <td>Burst EDO</td>
  </tr>
  <tr>
    <td>Bit 10</td>
    <td>SDRAM</td>
  </tr>
  <tr>
    <td>Bits 11:15</td>
    <td>Reserved, must be zero</td>
  </tr>
</table>

3.3.7.2 Memory Module Information - Memory Size

The Size fields of the Memory Module Configuration Information structure define the amount of memory currently installed (and enabled) in a memory-module connector.

The Installed Size fields identify the size of the memory module that is installed in the socket, as determined by reading and correlating the module’s presence-detect information. If the system does not support presence-detect mechanisms, the Installed Size field is set to 7Dh to indicate that the installed size is not determinable. The Enabled Size field identifies the amount of memory currently enabled for the system’s use from the module. If a module is known to be installed in a connector, but all memory in the module has been disabled due to error, the Enabled Size field is set to 7Eh.

<table>
  <tr>
    <th>Byte Bit Range</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bits 0:6</td>
    <td>Size (n), where 2**n is the size in MB with three special-case values:<br>7Dh Not determinable (Installed Size only)<br>7Eh Module is installed, but no memory has been enabled<br>7Fh Not installed</td>
  </tr>
  <tr>
    <td>Bit 7</td>
    <td>Defines whether the memory module has a single- (0) or double-bank (1) connection.</td>
  </tr>
</table>

3.3.7.3 Memory Subsystem Example

A system utilizes a memory controller that supports up to 4-32MB 5V 70ns parity SIMMs. The memory module sockets are used in pairs A1/A2 and B1/B2 to provide a 64-bit data path to the CPU. No mechanism is provided by the system to read the SIMM IDs. RAS-0 and -1 are connected to the front-and back-size banks of the SIMMs in the A1/A2 sockets and RAS-2 and -3 are similarly connected to the B1/B2 sockets. The current installation is an 8MB SIMM in sockets A1 and A2, 16MB total.
<table>
  <tr>
    <th>db</th>
    <th>5</th>
    <th>; Memory Controller Information</th>
  </tr>
  <tr>
    <td></td>
    <td>23</td>
    <td>; Length = 15 + 2*4</td>
  </tr>
  <tr>
    <td></td>
    <td>14</td>
    <td>; Memory Controller Handle</td>
  </tr>
  <tr>
    <td></td>
    <td>4</td>
    <td>; 8-bit parity error detection</td>
  </tr>
  <tr>
    <td></td>
    <td>00000100b</td>
    <td>; No error correction provided</td>
  </tr>
  <tr>
    <td></td>
    <td>03h</td>
    <td>; 1-way interleave supported</td>
  </tr>
  <tr>
    <td></td>
    <td>03h</td>
    <td>; 1-way interleave currently used</td>
  </tr>
  <tr>
    <td></td>
    <td>5</td>
    <td>; Maximum memory-module size supported is 32MB (2**5)</td>
  </tr>
  <tr>
    <td></td>
    <td>00000100b</td>
    <td>; Only 70ns SIMMs supported</td>
  </tr>
  <tr>
    <td></td>
    <td>00A4h</td>
    <td>; Standard, parity SIMMs supported</td>
  </tr>
  <tr>
    <td></td>
    <td>00000001b</td>
    <td>; 5V provided to each socket</td>
  </tr>
  <tr>
    <td></td>
    <td>4</td>
    <td>; 4 memory-module sockets supported</td>
  </tr>
  <tr>
    <td></td>
    <td>15</td>
    <td>; 1st Memory Module Handle</td>
  </tr>
  <tr>
    <td></td>
    <td>16</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>17</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>18</td>
    <td>; 4th ...</td>
  </tr>
  <tr>
    <td></td>
    <td>0000h</td>
    <td>; End-of-structure termination</td>
  </tr>
  <tr>
    <th>db</th>
    <th>6</th>
    <th>; Memory Module Information</th>
  </tr>
  <tr>
    <td></td>
    <td>0Ch</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>15</td>
    <td>; Handle</td>
  </tr>
  <tr>
    <td></td>
    <td>1</td>
    <td>; Reference Designation string #1</td>
  </tr>
  <tr>
    <td></td>
    <td>01h</td>
    <td>; Socket connected to RAS-0 and RAS-1</td>
  </tr>
  <tr>
    <td></td>
    <td>00000010b</td>
    <td>; Current speed is Unknown, since can’t read SIMM IDs</td>
  </tr>
  <tr>
    <td></td>
    <td>00000100b</td>
    <td>; Upgrade speed is 70ns, since that’s all that’s supported</td>
  </tr>
  <tr>
    <td></td>
    <td>00A4h</td>
    <td>; Current SIMM must be standard parity</td>
  </tr>
  <tr>
    <td></td>
    <td>7Dh</td>
    <td>; Installed size indeterminable (no SIMM IDs)</td>
  </tr>
  <tr>
    <td></td>
    <td>83h</td>
    <td>; Enabled size is double-bank 8MB (2**3)</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; No errors</td>
  </tr>
  <tr>
    <td></td>
    <td>"A1",0</td>
    <td>; String#1: Reference Designator</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; End-of-strings</td>
  </tr>
  <tr>
    <th>db</th>
    <th>6</th>
    <th>; Memory Module Information</th>
  </tr>
  <tr>
    <td></td>
    <td>0Ch</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>16</td>
    <td>; Handle</td>
  </tr>
  <tr>
    <td></td>
    <td>1</td>
    <td>; Reference Designation string #1</td>
  </tr>
  <tr>
    <td></td>
    <td>01h</td>
    <td>; Socket connected to RAS-0 and RAS-1</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; Current speed is Unknown, since can’t read SIMM IDs</td>
  </tr>
  <tr>
    <td></td>
    <td>00A4h</td>
    <td>; Current SIMM must be standard parity</td>
  </tr>
  <tr>
    <td></td>
    <td>7Dh</td>
    <td>; Installed size indeterminable (no SIMM IDs)</td>
  </tr>
  <tr>
    <td></td>
    <td>83h</td>
    <td>; Enabled size is double-bank 8MB (2**3)</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; No errors</td>
  </tr>
  <tr>
    <td></td>
    <td>"A2",0</td>
    <td>; String#1: Reference Designator</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; End-of-strings</td>
  </tr>
  <tr>
    <th>db</th>
    <th>6</th>
    <th>; Memory Module Information</th>
  </tr>
  <tr>
    <td></td>
    <td>0Ch</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>17</td>
    <td>; Handle</td>
  </tr>
  <tr>
    <td></td>
    <td>1</td>
    <td>; Reference Designation string #1</td>
  </tr>
  <tr>
    <td></td>
    <td>23h</td>
    <td>; Socket connected to RAS-2 and RAS-3</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; Current speed is Unknown, since can’t read SIMM IDs</td>
  </tr>
  <tr>
    <td></td>
    <td>0001h</td>
    <td>; Nothing appears to be installed (Other)</td>
  </tr>
  <tr>
    <td></td>
    <td>7Dh</td>
    <td>; Installed size indeterminable (no SIMM IDs)</td>
  </tr>
  <tr>
    <td></td>
    <td>7Fh</td>
    <td>; Enabled size is 0 (nothing installed)</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; No errors</td>
  </tr>
  <tr>
    <td></td>
    <td>"B1",0</td>
    <td>; String#1: Reference Designator</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; End-of-strings</td>
  </tr>
  <tr>
    <th>db</th>
    <th>6</th>
    <th>; Memory Module Information</th>
  </tr>
  <tr>
    <td></td>
    <td>0Ch</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>18</td>
    <td>; Handle</td>
  </tr>
  <tr>
    <td></td>
    <td>1</td>
    <td>; Reference Designation string #1</td>
  </tr>
  <tr>
    <td></td>
    <td>23h</td>
    <td>; Socket connected to RAS-2 and RAS-3</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; Current speed is Unknown, since can’t read SIMM IDs</td>
  </tr>
  <tr>
    <td></td>
    <td>0001h</td>
    <td>; Nothing appears to be installed (Other)</td>
  </tr>
  <tr>
    <td></td>
    <td>7Dh</td>
    <td>; Installed size indeterminable (no SIMM IDs)</td>
  </tr>
  <tr>
    <td></td>
    <td>7Fh</td>
    <td>; Enabled size is 0 (nothing installed)</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; No errors</td>
  </tr>
  <tr>
    <td></td>
    <td>"B2",0</td>
    <td>; String#1: Reference Designator</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>; End-of-strings</td>
  </tr>
</table>
3.3.8 Cache Information (Type 7)

The information in this structure defines the attributes of CPU cache device in the system. One structure is specified for each such device, whether the device is internal to or external to the CPU module. Cache modules can be associated with a processor structure in one or two ways depending on the SMBIOS version, see 3.3.5 Processor Information (Type 4) on page 42 and 3.3.15 Group Associations (Type 14) on page 60 for more information.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>7</td>
    <td>Cache Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The value is 0Fh for v2.0 implementations, or 13h for v2.1 implementations.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Socket Designation</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String Number for Reference Designation Example: "CACHE1", 0</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.0+</td>
    <td>Cache Configuration</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Bits 15:10 Reserved, must be zero<br>Bits 9:8 Operational Mode<br>00b Write Through<br>01b Write Back<br>10b Varies with Memory Address<br>11b Unknown<br>Bit 7 Enabled/Disabled (at boot time)<br>1b Enabled<br>0b Disabled<br>Bits 6:5 Location, relative to the CPU module:<br>00b Internal<br>01b External<br>10b Reserved<br>11b Unknown<br>Bit 4 Reserved, must be zero<br>Bit 3 Cache Socketed<br>1b Socketed<br>0b Not Socketed<br>Bits 2:0 Cache Level - 1 through 8, e.g. an L1 cache would use value 000b and an L3 cache would use 010b.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.0+</td>
    <td>Maximum Cache Size</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Maximum size that can be installed<br>Bit 15 Granularity<br>0 - 1K granularity<br>1 - 64K granularity<br>Bits 14:0 Max size in given granularity</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>2.0+</td>
    <td>Installed Size</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Same format as Max Cache Size field, set to 0 if no cache is installed.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.0+</td>
    <td>Supported SRAM Type</td>
    <td>WORD</td>
    <td>Bit Field</td>
    <td>See 3.3.8.1</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>2.0+</td>
    <td>Current SRAM Type</td>
    <td>WORD</td>
    <td>Bit Field</td>
    <td>See 3.3.8.1</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>2.1+</td>
    <td>Cache Speed</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The cache module speed, in nanoseconds. The value is 0 if the speed is unknown.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>2.1+</td>
    <td>Error Correction Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The error-correction scheme supported by this cache component, see 3.3.8.2.</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>2.1+</td>
    <td>System Cache Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The logical type of cache, see 3.3.8.3.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>2.1+</td>
    <td>Associativity</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The associativity of the cache, see 3.3.8.4.</td>
  </tr>
</table>

3.3.8.1 Cache Information - SRAM Type

<table>
  <tr>
    <th>Word Bit Position</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>Other</td>
  </tr>
</table>
<table>
  <tr>
    <th>Word Bit Position</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>Non-Burst</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>Burst</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>Pipeline Burst</td>
  </tr>
  <tr>
    <td>Bit 5</td>
    <td>Synchronous</td>
  </tr>
  <tr>
    <td>Bit 6</td>
    <td>Asynchronous</td>
  </tr>
  <tr>
    <td>Bits 7:15</td>
    <td>Reserved, must be zero</td>
  </tr>
</table>

3.3.8.2 Cache Information — Error Correction Type

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Parity</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Single-bit ECC</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Multi-bit ECC</td>
  </tr>
</table>

3.3.8.3 Cache Information — System Cache Type

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Instruction</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Data</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Unified</td>
  </tr>
</table>

3.3.8.4 Cache Information — Associativity

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Direct Mapped</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2-way Set-Associative</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>4-way Set-Associative</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Fully Associative</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>8-way Set-Associative</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>16-way Set-Associative</td>
  </tr>
</table>

3.3.9 Port Connector Information (Type 8)

The information in this structure defines the attributes of a system port connector, e.g. parallel, serial, keyboard, or mouse ports. The port’s type and connector information are provided. One structure is present for each port provided by the system.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>8</td>
    <td>Connector Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>9h</td>
    <td></td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Internal Reference Designator</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for Internal Reference Designator, i.e. internal to the system enclosure, e.g. 'J101', 0</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Internal Connector Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Internal Connector type. See 3.3.9.2</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>External Reference Designator</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the External Reference Designation external to the system enclosure, e.g. 'COM A', 0</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>External Connector Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>External Connector type. See 3.3.9.2</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Port Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Describes the function of the port. See 3.3.9.3</td>
  </tr>
</table>

3.3.9.1 Port Information Example

The following structure shows an example where a DB-9 Pin Male connector on the System Backpanel (COM A) is connected to the System Board via a 9 Pin Dual Inline connector (J101).

db   8      ; Indicates Connector Type
db   9h     ; Length
dw   ?      ; Reserved for handle
db   01h    ; String 1 - Internal Reference Designation
db   18h    ; 9 Pin Dual Inline
db   02h    ; String 2 - External Reference Designation
db   08h    ; DB-9 Pin Male
db   09h    ; 16550A Compatible
db   'J101',0 ; Internal reference
db   'COM A',0 ; External reference
db   0

If an External Connector is not used (as in the case of a CD-ROM Sound connector) then the External Reference Designator and the External Connector type should be set to zero. If an Internal Connector is not used (as in the case of a soldered on Parallel Port connector which extends outside of the chassis) then the Internal Reference Designation and Connector Type should be set to zero.

3.3.9.2 Port Information - Connector Types

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Centronics</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Mini Centronics</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Proprietary</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>DB-25 pin male</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>DB-25 pin female</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>DB-15 pin male</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>DB-15 pin female</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>DB-9 pin male</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>DB-9 pin female</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>RJ-11</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>RJ-45</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>50 Pin MiniSCSI</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Mini-DIN</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Micro-DIN</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>PS/2</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>Infrared</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>HP-HIL</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>Access Bus (USB)</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>SSA SCSI</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>14h</td>
    <td>Circular DIN-8 male</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>Circular DIN-8 female</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>On Board IDE</td>
  </tr>
  <tr>
    <td>17h</td>
    <td>On Board Floppy</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>9 Pin Dual Inline (pin 10 cut)</td>
  </tr>
  <tr>
    <td>19h</td>
    <td>25 Pin Dual Inline (pin 26 cut)</td>
  </tr>
  <tr>
    <td>1Ah</td>
    <td>50 Pin Dual Inline</td>
  </tr>
  <tr>
    <td>1Bh</td>
    <td>68 Pin Dual Inline</td>
  </tr>
  <tr>
    <td>1Ch</td>
    <td>On Board Sound Input from CD-ROM</td>
  </tr>
  <tr>
    <td>1Dh</td>
    <td>Mini-Centronics Type-14</td>
  </tr>
  <tr>
    <td>1Eh</td>
    <td>Mini-Centronics Type-26</td>
  </tr>
  <tr>
    <td>1Fh</td>
    <td>Mini-jack (headphones)</td>
  </tr>
  <tr>
    <td>20h</td>
    <td>BNC</td>
  </tr>
  <tr>
    <td>21h</td>
    <td>1394</td>
  </tr>
  <tr>
    <td>A0h</td>
    <td>PC-98</td>
  </tr>
  <tr>
    <td>A1h</td>
    <td>PC-98Hireso</td>
  </tr>
  <tr>
    <td>A2h</td>
    <td>PC-H98</td>
  </tr>
  <tr>
    <td>A3h</td>
    <td>PC-98Note</td>
  </tr>
  <tr>
    <td>A4h</td>
    <td>PC-98Full</td>
  </tr>
  <tr>
    <td>FFh</td>
    <td>Other - Use Reference Designator Strings to supply information.</td>
  </tr>
</table>

3.3.9.3 Port Types

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Parallel Port XT/AT Compatible</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Parallel Port PS/2</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Parallel Port ECP</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Parallel Port EPP</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Parallel Port ECP/EPP</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Serial Port XT/AT Compatible</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Serial Port 16450 Compatible</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Serial Port 16550 Compatible</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Serial Port 16550A Compatible</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>SCSI Port</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>MIDI Port</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Joy Stick Port</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Keyboard Port</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Mouse Port</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>SSA SCSI</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>USB</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>FireWire (IEEE P1394)</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>PCMCIA Type II</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>PCMCIA Type II</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>PCMCIA Type III</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>Cardbus</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>Access Bus Port</td>
  </tr>
  <tr>
    <td>17h</td>
    <td>SCSI II</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>SCSI Wide</td>
  </tr>
  <tr>
    <td>19h</td>
    <td>PC-98</td>
  </tr>
  <tr>
    <td>1Ah</td>
    <td>PC-98-Hireso</td>
  </tr>
  <tr>
    <td>1Bh</td>
    <td>PC-H98</td>
  </tr>
  <tr>
    <td>1Ch</td>
    <td>Video Port</td>
  </tr>
  <tr>
    <td>1Dh</td>
    <td>Audio Port</td>
  </tr>
  <tr>
    <td>1Eh</td>
    <td>Modem Port</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>1Fh</td>
    <td>Network Port</td>
  </tr>
  <tr>
    <td>A0h</td>
    <td>8251 Compatible</td>
  </tr>
  <tr>
    <td>A1h</td>
    <td>8251 FIFO Compatible</td>
  </tr>
  <tr>
    <td>0FFh</td>
    <td>Other</td>
  </tr>
</table>

3.3.10 System Slots (Type 9)

The information in this structure defines the attributes of a system slot. One structure is provided for each slot in the system.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>9</td>
    <td>System Slot Structure Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>0Ch for v2.0 implementations; 0Dh for v2.1 and later.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Slot Designation</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for reference designation e.g. 'PCI-1',0</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.0+</td>
    <td>Slot Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.10.1</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Slot Data Bus Width</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.10.2</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.0+</td>
    <td>Current Usage</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.10.3</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.0+</td>
    <td>Slot Length</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.10.4</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>2.0+</td>
    <td>Slot ID</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>See 3.3.10.5</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.0+</td>
    <td>Slot Characteristics 1</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>See 3.3.10.6</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.1+</td>
    <td>Slot Characteristics 2</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>See 3.3.10.7</td>
  </tr>
</table>

3.3.10.1 System Slots - Slot Type

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>ISA</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>MCA</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>EISA</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>PCI</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>PC Card (PCMCIA)</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>VL-VESA</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Proprietary</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Processor Card Slot</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Proprietary Memory Card Slot</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>I/O Riser Card Slot</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>NuBus</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>PCI - 66MHz Capable</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>AGP</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>AGP 2X</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>AGP 4X</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>PCI-X</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>AGP 8X</td>
  </tr>
  <tr>
    <td>A0h</td>
    <td>PC-98/C20</td>
  </tr>
  <tr>
    <td>A1h</td>
    <td>PC-98/C24</td>
  </tr>
  <tr>
    <td>A2h</td>
    <td>PC-98/E</td>
  </tr>
  <tr>
    <td>A3h</td>
    <td>PC-98/Local Bus</td>
  </tr>
  <tr>
    <td>A4h</td>
    <td>PC-98/Card</td>
  </tr>
  <tr>
    <td>A5h</td>
    <td>PCI Express</td>
  </tr>
</table>
3.3.10.2 System Slots - Slot Data Bus Width

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

Slot Data Bus Width meanings of type “n bit” are for parallel bus such as PCI. Slot Data Bus Width meanings of type “nx or xn” are for serial bus such as PCI Express.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>8 bit</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>16 bit</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>32 bit</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>64 bit</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>128 bit</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>1x or x1</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>2x or x2</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>4x or x4</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>8x or x8</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>12x or x12</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>16x or x16</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>32x or x32</td>
  </tr>
</table>

3.3.10.3 System Slots - Current Usage

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Available</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>In use</td>
  </tr>
</table>

3.3.10.4 System Slots - Slot Length

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Short Length</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Long Length</td>
  </tr>
</table>

3.3.10.5 System Slots — Slot ID

The Slot ID field of the System Slot structure provides a mechanism to correlate the physical attributes of the slot to its logical access method (which varies based on the Slot Type field). The Slot ID field has meaning only for the slot types described below:

<table>
  <tr>
    <th>Slot Type</th>
    <th>Slot ID Field Meaning</th>
  </tr>
  <tr>
    <td>MCA</td>
    <td>Identifies the logical Micro Channel slot number, in the range 1 to 15, in offset 09h. Offset 0Ah is set to 0.</td>
  </tr>
  <tr>
    <td>EISA</td>
    <td>Identifies the logical EISA slot number, in the range 1 to 15, in offset 09h. Offset 0Ah is set to 0.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Slot Type</th>
    <th>Slot ID Field Meaning</th>
  </tr>
  <tr>
    <td>PCI/AGP/PCI-X</td>
    <td>Identifies the value present in the Slot Number field of the PCI Interrupt Routing table entry that is associated with this slot, in offset 09h — offset 0Ah is set to 0. The table is returned by the “Get PCI Interrupt Routing Options” PCI BIOS function call and provided directly in the <i>PCI IRQ Routing Table Specification</i> ($PIRQ). Software can determine the PCI bus number and device associated with the slot by matching the "Slot ID" to an entry in the routing-table ... and ultimately determine what device is present in that slot.<br><br><i>Note: This definition also applies to the 66MHz-capable PCI slots.</i></td>
  </tr>
  <tr>
    <td>PCMCIA</td>
    <td>Identifies the Adapter Number (offset 09h) and Socket Number (offset 0Ah) to be passed to PCMCIA Socket Services to identify this slot.</td>
  </tr>
</table>

3.3.10.6 Slot Characteristics 1

<table>
  <tr>
    <th>BYTE Bit Position</th>
    <th>Meaning if Set</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>Characteristics Unknown</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Provides 5.0 Volts</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>Provides 3.3 Volts</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>Slot’s opening is shared with another slot, e.g. PCI/EISA shared slot.</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>PC Card slot supports PC Card-16</td>
  </tr>
  <tr>
    <td>Bit 5</td>
    <td>PC Card slot supports CardBus</td>
  </tr>
  <tr>
    <td>Bit 6</td>
    <td>PC Card slot supports Zoom Video</td>
  </tr>
  <tr>
    <td>Bit 7</td>
    <td>PC Card slot supports Modem Ring Resume</td>
  </tr>
</table>

3.3.10.7 Slot Characteristics 2

<table>
  <tr>
    <th>BYTE Bit Position</th>
    <th>Meaning if Set</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>PCI slot supports Power Management Enable (PME#) signal</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Slot supports hot-plug devices</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>PCI slot supports SMBus signal</td>
  </tr>
  <tr>
    <td>Bits 3:7</td>
    <td>Reserved, set to 0</td>
  </tr>
</table>

3.3.11 On Board Devices Information (Type 10)

The information in this structure defines the attributes of devices that are onboard (soldered onto) a system element, usually the baseboard. In general, an entry in this table implies that the BIOS has some level of control over the enabling of the associated device for use by the system.

<b>Important Note:</b> Since this structure was originally defined with the <i>Length</i> implicitly defining the number of devices present, no further fields can be added to this structure without adversely affecting existing software’s ability to properly parse the data. Thus, if additional fields are required for this structure type a brand new structure must be defined to add a device count field, carry over the existing fields, and add the new information.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>10</td>
    <td>On Board Devices Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Computed by the BIOS as 4 + 2 * (Number of Devices). The user of this structure determines the number of devices as (Length - 4) / 2.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>4+2*(n-1)</td>
    <td>Device<sub>n</sub> Type, n ranges from 1 to Number of Devices</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Bit 7 Device<sub>n</sub> Status<br>1 - Device Enabled<br>0 - Device Disabled<br>Bits 6:0 Type of Device (See 3.3.11.1)</td>
  </tr>
  <tr>
    <td>5+2*(n-1)</td>
    <td>Description String</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number of device description</td>
  </tr>
</table>

Note: There may be a single structure instance containing the information for all onboard devices or there may be a unique structure instance for each onboard device.

3.3.11.1 Onboard Device Types

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Video</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>SCSI Controller</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Ethernet</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Token Ring</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Sound</td>
  </tr>
</table>

3.3.12 OEM Strings (Type 11)

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>11</td>
    <td>OEM Strings Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>5h</td>
    <td></td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Count</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Number of strings</td>
  </tr>
</table>

This structure contains free form strings defined by the OEM. Examples of this are: Part Numbers for Reference Documents for the system, contact information for the manufacturer, etc.

3.3.13 System Configuration Options (Type 12)

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>12</td>
    <td>Configuration Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>5h</td>
    <td></td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Count</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Number of strings</td>
  </tr>
</table>

This structure contains information required to configure the base board’s Jumpers and Switches. Examples of this are: “JP2: 1-2 Cache Size is 256K, 2-3 Cache Size is 512K” “SW1-1: Close to Disable On Board Video”

3.3.14 BIOS Language Information (Type 13)

The information in this structure defines the installable language attributes of the BIOS.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>13</td>
    <td>Language Information Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>16h</td>
    <td></td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Installable Languages</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Number of languages available. Each available language will have a description string. This field contains the number of strings that follow the formatted area of the structure.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.1+</td>
    <td>Flags</td>
    <td>BYTE</td>
    <td>Bit Field</td>
    <td>Bits 7:1 Reserved<br>Bit 0 If set to 1, the Current Language strings use the abbreviated format. Otherwise, the strings use the long format. See below for details.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Reserved</td>
    <td>15 BYTES</td>
    <td>0</td>
    <td>Reserved for future use</td>
  </tr>
  <tr>
    <td>015h</td>
    <td>2.0+</td>
    <td>Current Language</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number (one-based) of the currently installed language.</td>
  </tr>
</table>

The strings describing the languages follow the Current Language byte. The format of the strings depends on the value present in bit 0 of the byte at offset 05h in the structure.

If the bit is 0, each language string is in the form “ISO 639 Language Name | ISO 3166 Territory Name | Encoding Method”. See the Example 1 below.

If the bit is 1, each language string consists of the 2-character ISO 639 Language Name directly followed by the 2-character ISO 3166 Territory Name. See Example 2 below.

Note: Refer to the Desktop Management Interface Specification, V1.0, Appendix A (ISO 639) and Appendix B (ISO 3166) for additional information.

Example 1: BIOS Language Information (Long Format)

db 13 ; language information
db 16h ; length
dw ?? ; handle
db 3 ; three languages available
db 0 ; use long-format for language strings
db 15 dup (0) ; reserved
db 2 ; current language is French Canadian
db 'en|US|iso8859-1',0 ; language 1 is US English
db 'fr|CA|iso8859-1',0 ; language 2 is French Canadian
db 'ja|JP|unicode',0 ; language 3 is Japanese
db 0 ; Structure termination

Example 2: BIOS Language Information (Abbreviated Format)

db 13 ; language information
db 16h ; length
dw ?? ; handle
db 3 ; three languages available
db 01h ; use abbreviated format for language strings
db 15 dup (0) ; reserved
db 2 ; current language is French Canadian
db 'enUS',0 ; language 1 is US English
db 'frCA',0 ; language 2 is French Canadian
db 'jaJP',0 ; language 3 is Japanese
db 0 ; Structure termination

3.3.15 Group Associations (Type 14)

Important Note: Since this structure was originally defined with the Length implicitly defining the number of items present, no further fields can be added to this structure without adversely affecting existing software’s ability to properly parse the data. Thus, if additional fields are required for this structure type a brand new structure must be defined to add an item count field, carry over the existing fields, and add the new information.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>14</td>
    <td>Group Associations Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Computed by the BIOS as 5 + (3 bytes for each item in the group). The user of this structure determines the number of items as (Length - 5) / 3.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Group Name</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number of string describing the group</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Item Type</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Item (Structure) Type of this member</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Item Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Handle corresponding to this structure</td>
  </tr>
</table>

The Group Associations structure is provided for OEMs who want to specify the arrangement or hierarchy of certain components (including other Group Associations) within the system. For example, you can use the Group Associations structure to indicate that two CPU’s share a common external cache system. These structures might look as follows:

First Group Association Structure:
db 14 ; Group Association structure
db 11 ; Length
dw 28h ; Handle
db 01h ; String Number (First String)
db 04 ; CPU Structure
dw 08h ; CPU Structure’s Handle
db 07 ; Cache Structure
dw 09h ; Cache Structure’s Handle
db 'Primary CPU Module', 0
db 0

Second Group Association Structure:
db 14 ; Group Association structure
db 11 ; Length
dw 29h ; Handle
db 01h ; String Number (First String)
db 04 ; CPU Structure
dw 0Ah ; CPU Structure’s Handle
db 07 ; Cache Structure
dw 09h ; Cache Structure’s Handle
db 'Secondary CPU Module', 0
db 0

In the examples above, CPU structures 08h and 0Ah are associated with the same cache, 09h. This relationship could also be specified as a single group:

db 14 ; Group Association structure
db 14 ; Length (5 + 3 * 3)
dw 28h ; Structure handle for Group Association
db 1 ; String Number (First string)
db 4 ; 1st CPU
dw 08h ; CPU structure handle
db 4 ; 2nd CPU
dw 0Ah ; CPU structure handle
db 7 ; Shared cache
dw 09h ; Cache structure handle
db 'Dual-Processor CPU Complex', 0
db 0

3.3.16 System Event Log (Type 15)

The presence of this structure within the SMBIOS data returned for a system indicates that the system supports an event log. An event log is a fixed-length area within a non-volatile storage element, starting with a fixed-length (and vendor-specific) header record, followed by one or more variable-length log records. See 3.3.16.4 Event Log Organization on page 65 for more information. Refer also to 2.2.5 Function 54h – SMBIOS Control on page 23 for interfaces that can be used to control the event-log.

An application can implement event-log change notification by periodically reading the System Event Log structure (via its assigned handle) looking for a change in the Log Change Token. This token uniquely identifies the last time the event log was updated. When it sees the token changed, the application can retrieve the entire event log and determine the changes since the last time it read the event log.
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.0+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>15</td>
    <td>Event Log Type Indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.0+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Var</td>
    <td>Length of the structure, including the Type and Length fields. The Length is 14h for v2.0 implementations or computed by the BIOS as 17h+(x*y) for v2.1 and higher implementations — where x is the value present at offset 15h and y is the value present at offset 16h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.0+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Var</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.0+</td>
    <td>Log Area Length</td>
    <td>WORD</td>
    <td>Var</td>
    <td>The length, in bytes, of the overall event log area, from the first byte of header to the last byte of data.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.0+</td>
    <td>Log Header Start Offset</td>
    <td>WORD</td>
    <td>Var</td>
    <td>Defines the starting offset (or index) within the nonvolatile storage of the event-log’s header, from the Access Method Address. For single-byte indexed I/O accesses, the most-significant byte of the start offset is set to 00h.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.0+</td>
    <td>Log Data Start Offset</td>
    <td>WORD</td>
    <td>Var</td>
    <td>Defines the starting offset (or index) within the nonvolatile storage of the event-log’s first data byte, from the Access Method Address. For single-byte indexed I/O accesses, the most-significant byte of the start offset is set to 00h.<br><br><i>Note:</i> The data directly follows any header information. Therefore, the header length can be determined by subtracting the <i>Header Start Offset</i> from the <i>Data Start Offset</i>.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>2.0+</td>
    <td>Access Method</td>
    <td>BYTE</td>
    <td>Var</td>
    <td>Defines the Location and Method used by higher-level software to access the log area, one of:<br><br>00h Indexed I/O: 1 8-bit index port, 1 8-bit data port. The Access Method Address field contains the 16-bit I/O addresses for the index and data ports. See 3.3.16.2.1 for usage details.<br>01h Indexed I/O: 2 8-bit index ports, 1 8-bit data port. The Access Method Address field contains the 16-bit I/O address for the index and data ports. See 3.3.16.2.2 for usage details.<br>02h Indexed I/O: 1 16-bit index port, 1 8-bit data port. The Access Method Address field contains the 16-bit I/O address for the index and data ports. See 3.3.16.2.3 for usage details.<br>03h Memory-mapped physical 32-bit address. The Access Method Address field contains the 4-byte (Intel DWORD format) starting physical address.<br>04h Available via General-Purpose NonVolatile Data functions, see 2.2.6 on page 25 for more information. The Access Method Address field contains the 2-byte (Intel WORD format) GPNV handle.<br>05h-7Fh Available for future assignment via this specification<br>80h-FFh BIOS Vendor/OEM-specific</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.0+</td>
    <td>Log Status<sup>4</sup></td>
    <td>BYTE</td>
    <td>Var</td>
    <td>This bit-field describes the current status of the system event-log:<br>Bits 7:2 Reserved, set to 0's<br>Bit 1 Log area full, if 1<br>Bit 0 Log area valid, if 1</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.0+</td>
    <td>Log Change<sup>4</sup> Token</td>
    <td>DWORD</td>
    <td>Var</td>
    <td>Unique token that is reassigned every time the event log changes. Can be used to determine if additional events have occurred since the last time the log was read.</td>
  </tr>
</table>

<sup>4</sup> The Log Status and Log Change Token fields might not be up-to-date (dynamic) when the structure is accessed using the table interface.
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>10h</td>
    <td>2.0+</td>
    <td>Access Method Address</td>
    <td>DWORD</td>
    <td>Var</td>
    <td>The address associated with the access method; the data present depends on the Access Method field value. The area’s format can be described by the following 1-byte-packed ‘C’ union:
union
{
    struct
    {
        short IndexAddr;
        short DataAddr;
    } IO;
    long PhysicalAddr32;
    short GPNVHandle;
} AccessMethodAddress;</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>2.1+</td>
    <td>Log Header Format</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the format of the log header area, see 3.3.16.5 for details.</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>2.1+</td>
    <td>Number of Supported Log Type Descriptors (x)</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Number of supported event log type descriptors that follow. If the value is 0, the list that starts at offset 17h is not present.</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>2.1+</td>
    <td>Length of each Log Type Descriptor (y)</td>
    <td>BYTE</td>
    <td>2</td>
    <td>Identifies the number of bytes associated with each type entry in the list below. The value is currently “hard-coded” as 2, since each entry consists of two bytes. This field’s presence allows future additions to the type list. Software that interprets the following list should not assume a list entry’s length.</td>
  </tr>
  <tr>
    <td>17h to 17h+(x*y))-1</td>
    <td>2.1+</td>
    <td>List of Supported Event Log Type Descriptors</td>
    <td>Varies</td>
    <td>Var</td>
    <td>Contains a list of Event Log Type Descriptors (see 3.3.16.1), so long as the value specified in offset 15h is non-zero.</td>
  </tr>
</table>

3.3.16.1 Supported Event Log Type Descriptors

Each entry consists of a 1-byte type field and a 1-byte data-format descriptor, as defined by the following table. The presence of an entry identifies that the Log Type is supported by the system and the format of any variable data that accompanies the first bytes of the log’s variable data — a specific log record might have more variable data than specified by its Variable Data Format Type.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Log Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.16.6.1 on page 67 for list.</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Variable Data Format Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>See 3.3.16.6.2 on page 68 for list</td>
  </tr>
</table>

3.3.16.2 Indexed I/O Access Method

This section contains examples (in x86 assembly language) which detail the code required to access the “indexed I/O” event-log information.

3.3.16.2.1 1 8-bit Index, 1 8-bit Data (00h)

To access the event-log, the caller selects 1 of 256 unique data bytes by
1) Writing the byte data-selection value (index) to the IndexAddr I/O address
2) Reading or writing the byte data value to (or from) the DataAddr I/O address
mov dx, IndexAddr;Value from event-log structure
mov al, WhichLoc ;Identify offset to be accessed
out dx, al
mov dx, DataAddr ;Value from event-log structure
in al, dx ; Read current value

3.3.16.2.2 2 8-bit Index, 1 8-bit Data (01h)

To access the event-log, the caller selects 1 of 65536 unique data bytes by
1) Writing the least-significant byte data-selection value (index) to the IndexAddr I/O address
2) Writing the most-significant byte data-selection value (index) to the (IndexAddr+1) I/O address
3) Reading or writing the byte data value to (or from) the DataAddr I/O address

mov dx, IndexAddr;Value from event-log structure
mov ax, WhichLoc ;Identify offset to be accessed
out dx, al ;Select LSB offset
inc dx
xchg ah, al
out dx, al ;Select MSB offset
mov dx, DataAddr ;Value from event-log structure
in al, dx ;Read current value

3.3.16.2.3 1 16-bit Index, 1 8-bit Data (02h)

To access the event-log, the caller selects 1 of 65536 unique data bytes by
1) Writing the word data-selection value (index) to the IndexAddr I/O address
2) Reading or writing the byte data value to (or from) the DataAddr I/O address

mov dx, IndexAddr;Value from event-log structure
mov ax, WhichLoc ;Identify offset to be accessed
out dx, ax
mov dx, DataAddr ;Value from event-log structure
in al, dx ;Read current value

3.3.16.3 Access Method Address — DWORD Layout

<table>
  <tr>
    <th>Access Type</th>
    <th>BYTE 3</th>
    <th>BYTE 2</th>
    <th>BYTE 1</th>
    <th>BYTE 0</th>
  </tr>
  <tr>
    <td>00:02 — Indexed I/O</td>
    <td>Data MSB</td>
    <td>Data LSB</td>
    <td>Index MSB</td>
    <td>Index LSB</td>
  </tr>
  <tr>
    <td>03- Absolute Address</td>
    <td>Byte 3</td>
    <td>Byte 2</td>
    <td>Byte 1</td>
    <td>Byte 0</td>
  </tr>
  <tr>
    <td>04 - Use GPNV</td>
    <td>0</td>
    <td>0</td>
    <td>Handle MSB</td>
    <td>Handle LSB</td>
  </tr>
</table>

3.3.16.4 Event Log Organization

The event log is organized as an optional (and implementation-specific) fixed-length header, followed by one or more variable-length event records, as illustrated below. From one implementation to the next, the format of the log header and the size of the overall log area might change; all other required fields of the event log area will be consistent across all systems.

<table>
  <tr>
    <th colspan="9">Log Header (Optional)</th>
  </tr>
  <tr>
    <th>Type</th>
    <th>Length</th>
    <th>Year</th>
    <th>Month</th>
    <th>Day</th>
    <th>Hour</th>
    <th>Minute</th>
    <th>Second</th>
    <th>Log Variable Data</th>
  </tr>
  <tr>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Reqd</td>
    <td>Optional</td>
  </tr>
</table>

3.3.16.5 Log Header Format

The following table contains the byte enumeration values (available for SMBIOS v2.1 and later) that identify the standard formats of the event log headers.
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
    <th>See ...</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>No header, e.g. the header is 0 bytes in length.</td>
    <td></td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Type 1 log header</td>
    <td>3.3.16.5.1</td>
  </tr>
  <tr>
    <td>02h-7Fh</td>
    <td>Available for future assignment via this specification</td>
    <td></td>
  </tr>
  <tr>
    <td>80h-FFh</td>
    <td>BIOS Vendor or OEM-specific format</td>
    <td></td>
  </tr>
</table>

3.3.16.5.1 Log Header Type 1 Format

The type 1 event log header consists of the following fields:

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>OEM Reserved</td>
    <td>5 BYTES</td>
    <td>Varies</td>
    <td>Reserved area for OEM customization, not assignable by this specification.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Multiple Event Time Window</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The number of minutes which must pass between duplicate log entries which utilize a multiple-event counter, specified in BCD. The value ranges from 00h to 99h to represent 0 to 99 minutes.<br>See 3.3.16.6.3 Multiple-Event Counter on page 68 for usage details.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Multiple Event Count Increment</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The number of occurrences of a duplicate event that must pass before the multiple-event counter associated with the log entry is updated, specified as a numeric value in the range 1 to 255 (the value 0 is reserved).<br>See 3.3.16.6.3 Multiple-Event Counter on page 68 for usage details.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Pre-boot Event Log Reset — CMOS Address</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the CMOS RAM address (in the range 10h - FFh) associated with the Pre-boot Event Log Reset; the value is 00h if the feature is not supported. See below for usage details.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Pre-boot Event Log Reset — CMOS Bit Index</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the bit within the above CMOS RAM location that is set to indicate that the log should be cleared. The value is specified in the range 0 to 7, where 0 specifies the LSB and 7 specified the MSB. See below for usage details.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>CMOS Checksum — Starting Offset</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the CMOS RAM address associated with the start of the area that is to be checksummed, if the value is non-0. If the value is 0, the CMOS Address field lies outside of a checksummed region in CMOS. See below for usage details.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>CMOS Checksum — Byte Count</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the number of consecutive CMOS RAM addresses, starting at the Starting Offset, that participate in the CMOS Checksum region associated with the pre-boot event log reset. See below for usage details.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>CMOS Checksum — Checksum Offset</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the CMOS RAM address associated with the start of two consecutive bytes into which the calculated checksum value is stored. See below for usage details.</td>
  </tr>
  <tr>
    <td>0Ch - 0Eh</td>
    <td>Reserved</td>
    <td>3 BYTES</td>
    <td>000000h</td>
    <td>Available for future assignment via this specification.</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>Header Revision</td>
    <td>BYTE</td>
    <td>01h</td>
    <td>Identifies the version of Type 1 header implemented.</td>
  </tr>
</table>

The Type 1 Log Header also provides pre-boot event log reset support. Application software can set a system-specific location of CMOS RAM memory (accessible via I/O ports 70h and 71h) to cause the event log to be cleared by the BIOS on the next reboot of the system.

To perform the field setting, application software follows these steps, so long as the Pre-boot Event Log Reset — CMOS Address field of the header is non-zero:
• Read the address specified from CMOS RAM set the bit specified by the CMOS Bit Index field to 1. Rewrite the CMOS RAM address with the updated data.

• If the CMOS Checksum — Starting Offset field is non-zero, recalculate the CMOS RAM checksum value for the range starting at the Starting Offset field for Byte Count bytes into a 2-byte value. Subtract that value from 0 to create the checksum value for the range and store that 2-byte value into the CMOS RAM; the least-significant byte of the value is stored at the CMOS RAM Checksum Offset and the most-significant byte of the value is stored at (Checksum Offset)+1.

3.3.16.6 Log Record Format

Each log record consists of a required fixed-length record header, followed by (optional) additional data which is defined by the event type. The fixed-length log record header is present as the first 8-bytes of each log record, regardless of event type, and consists of:

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Format</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Event Type</td>
    <td>BYTE</td>
    <td>Specifies the “Type” of event noted in an event-log entry as defined in 3.3.16.6.1</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Specifies the byte length of the event record, including the record’s Type and Length fields. The most-significant bit of the field specifies whether (0) or not (1) the record has been read. The implication of the record having been read is that the information in the log record has been processed by a higher software layer.</td>
  </tr>
  <tr>
    <td>02h-07h</td>
    <td>Date/Time Fields</td>
    <td>BYTE</td>
    <td>These fields contain the BCD representation of the date and time (as read from CMOS) of the occurrence of the event. The information is present in year, month, day, hour, minute, and second order.<br><b>Note:</b> The century portion of the two-digit year is implied as ‘19’ for year values in the range 80h to 99h and ‘20’ for year values in the range 00h to 79h.</td>
  </tr>
  <tr>
    <td>08h+</td>
    <td>Log Variable Data</td>
    <td>Var</td>
    <td>This field contains the (optional) event-specific additional status information.</td>
  </tr>
</table>

3.3.16.6.1 Event Log Types

<table>
  <tr>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Reserved.</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Single-bit ECC memory error</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Multi-bit ECC memory error</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Parity memory error</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Bus time-out</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>I/O Channel Check</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Software NMI</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>POST Memory Resize</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>POST Error</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>PCI Parity Error</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>PCI System Error</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>CPU Failure</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>EISA FailSafe Timer time-out</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Correctable memory log disabled</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Logging disabled for a specific Event Type – too many errors of the same type received in a short amount of time.</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>Reserved</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>System Limit Exceeded (e.g. voltage or temperature threshold exceeded).</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>Asynchronous hardware timer expired and issued a system reset.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>System configuration information</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>Hard-disk information</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>System reconfigured</td>
  </tr>
</table>
<table>
  <tr>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>15h</td>
    <td>Uncorrectable CPU-complex error</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>Log Area Reset/Cleared</td>
  </tr>
  <tr>
    <td>17h</td>
    <td>System boot. If implemented, this log entry is guaranteed to be the first one written on any system boot.</td>
  </tr>
  <tr>
    <td>18h-7Fh</td>
    <td>Unused, available for assignment by this specification.</td>
  </tr>
  <tr>
    <td>80h-FFh</td>
    <td>Available for system- and OEM-specific assignments.</td>
  </tr>
  <tr>
    <td>FFh</td>
    <td>End-of-log. When an application searches through the event-log records, the end of the log is identified when a log record with this type is found.</td>
  </tr>
</table>

3.3.16.6.2 Event Log Variable Data Format Types

The Variable Data Format Type, specified in the Event Log structure’s Supported Event Type fields, identifies the standard-format that application software can apply to the first n bytes of the associated Log Type’s variable data. Additional, OEM-specific, data might follow in the log’s variable data field.

<table>
  <tr>
    <th>Value</th>
    <th>Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>None</td>
    <td>No standard format data is available; the first byte of the variable data (if present) contains OEM-specific unformatted information.</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Handle</td>
    <td>The first WORD of the variable data contains the handle of the SMBIOS structure associated with the hardware element that failed.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Multiple-Event</td>
    <td>The first DWORD of the variable data contains a multiple-event counter (see 3.3.16.6.3 for details).</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Multiple-Event Handle</td>
    <td>The first WORD of the variable data contains the handle of the SMBIOS structure associated with the hardware element that failed; it is followed by a DWORD containing a multiple-event counter (see 3.3.16.6.3 for details).</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>POST Results Bitmap</td>
    <td>The first 2 DWORDs of the variable data contain the POST Results Bitmap, as described in 3.3.16.6.3.1 on page 69.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>System Management Type</td>
    <td>The first DWORD of the variable data contains a value that identifies a system-management condition. See 3.3.16.6.3.2on page 69 for the enumerated values.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Multiple-Event System Management Type</td>
    <td>The first DWORD of the variable data contains a value that identifies a system-management condition (see 3.3.16.6.3.2 on page 69 for the enumerated values). This DWORD is directly followed by a DWORD that contains a multiple-event counter (see 3.3.16.6.3 for details).</td>
  </tr>
  <tr>
    <td>07h-7Fh</td>
    <td>Unused</td>
    <td>Unused, available for assignment by this specification.</td>
  </tr>
  <tr>
    <td>80h-FFh</td>
    <td>OEM assigned</td>
    <td>Available for system- and OEM-specific assignments.</td>
  </tr>
</table>

3.3.16.6.3 Multiple-Event Counter

Some system events can be persistent; once they occur, it is possible to quickly fill the log with redundant multiple logs. The Multiple Event Count Increment (MECI) and Multiple Event Time Window (METW) values can be used to reduce the occurrence of these multiple logs while providing multiple event counts.

Note: These values are normally specified within the event log header, see 3.3.16.5.1 Log Header Type 1 Format on page 66 for an example; if the values aren’t specified in the header, the application software can assume that the MECI value is 1 and the METW value is 60 (minutes).

The multiple-event counter is a DWORD (32-bit) value that tracks the number of logs of the same type that have occurred within METW minutes. The counter value is initialized (in the log entry) to FFFFFFFFh, implying that only a single event of that type has been detected, and the internal BIOS counter5 specific to that log type is reset to 0. When the BIOS receives the next event of that type, it increments its internal counter and checks to see what recording of the error is to be performed:

5 All BIOS counters that support the Multiple-Event Counters are reset to zero each time the system boots.
1. A new log entry is written ... and the internal BIOS counter reset to 0, if the date/time of the original log entry is outside of METW minutes.

2. No recording ... (other than the internal counter increment) if the log’s current multiple-event counter is 00000000h or if the internal BIOS counter is less than MECI.

3. The next non-zero bit of the multiple-event counter is set to 0 ... otherwise.

3.3.16.6.3.1 POST Results Bitmap

This variable data type, when present, is expected to be associated with the POST Error (08h) event log type and identifies that one or more error types have occurred. The bitmap consists of two DWORD values, described in the table below. Any bit within the DWORD pair that is specified as Reserved is set to 0 within the log data and is available for assignment via this specification. A set bit ('1'b) at a DWORD bit position implies that the error associated with that position has occurred.

<table>
  <tr>
    <th>Bit Position</th>
    <th>First DWORD</th>
    <th>Second DWORD</th>
  </tr>
  <tr>
    <td>0</td>
    <td>Channel 2 Timer error</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>1</td>
    <td>Master PIC (8259 #1) error</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>2</td>
    <td>Slave PIC (8259 #2) error</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>3</td>
    <td>CMOS Battery Failure</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>4</td>
    <td>CMOS System Options Not Set</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>5</td>
    <td>CMOS Checksum Error</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>6</td>
    <td>CMOS Configuration Error</td>
    <td>Normally 0; available for OEM assignment</td>
  </tr>
  <tr>
    <td>7</td>
    <td>Mouse and Keyboard Swapped</td>
    <td>PCI Memory Conflict</td>
  </tr>
  <tr>
    <td>8</td>
    <td>Keyboard Locked</td>
    <td>PCI I/O Conflict</td>
  </tr>
  <tr>
    <td>9</td>
    <td>Keyboard Not Functional</td>
    <td>PCI IRQ Conflict</td>
  </tr>
  <tr>
    <td>10</td>
    <td>Keyboard Controller Not Functional</td>
    <td>PNP Memory Conflict</td>
  </tr>
  <tr>
    <td>11</td>
    <td>CMOS Memory Size Different</td>
    <td>PNP 32 bit Memory Conflict</td>
  </tr>
  <tr>
    <td>12</td>
    <td>Memory Decreased in Size</td>
    <td>PNP I/O Conflict</td>
  </tr>
  <tr>
    <td>13</td>
    <td>Cache Memory Error</td>
    <td>PNP IRQ Conflict</td>
  </tr>
  <tr>
    <td>14</td>
    <td>Floppy Drive 0 Error</td>
    <td>PNP DMA Conflict</td>
  </tr>
  <tr>
    <td>15</td>
    <td>Floppy Drive 1 Error</td>
    <td>Bad PNP Serial ID Checksum</td>
  </tr>
  <tr>
    <td>16</td>
    <td>Floppy Controller Failure</td>
    <td>Bad PNP Resource Data Checksum</td>
  </tr>
  <tr>
    <td>17</td>
    <td>Number of ATA Drives Reduced Error</td>
    <td>Static Resource Conflict</td>
  </tr>
  <tr>
    <td>18</td>
    <td>CMOS Time Not Set</td>
    <td>NVRAM Checksum Error, NVRAM Cleared</td>
  </tr>
  <tr>
    <td>19</td>
    <td>DDC Monitor Configuration Change</td>
    <td>System Board Device Resource Conflict</td>
  </tr>
  <tr>
    <td>20</td>
    <td>Reserved, set to 0</td>
    <td>Primary Output Device Not Found</td>
  </tr>
  <tr>
    <td>21</td>
    <td>Reserved, set to 0</td>
    <td>Primary Input Device Not Found</td>
  </tr>
  <tr>
    <td>22</td>
    <td>Reserved, set to 0</td>
    <td>Primary Boot Device Not Found</td>
  </tr>
  <tr>
    <td>23</td>
    <td>Reserved, set to 0</td>
    <td>NVRAM Cleared By Jumper</td>
  </tr>
  <tr>
    <td>24</td>
    <td>Second DWORD has valid data</td>
    <td>NVRAM Data Invalid, NVRAM Cleared</td>
  </tr>
  <tr>
    <td>25</td>
    <td>Reserved, set to 0</td>
    <td>FDC Resource Conflict</td>
  </tr>
  <tr>
    <td>26</td>
    <td>Reserved, set to 0</td>
    <td>Primary ATA Controller Resource Conflict</td>
  </tr>
  <tr>
    <td>27</td>
    <td>Reserved, set to 0</td>
    <td>Secondary ATA Controller Resource Conflict</td>
  </tr>
  <tr>
    <td>28</td>
    <td>Normally 0; available for OEM assignment</td>
    <td>Parallel Port Resource Conflict</td>
  </tr>
  <tr>
    <td>29</td>
    <td>Normally 0; available for OEM assignment</td>
    <td>Serial Port 1 Resource Conflict</td>
  </tr>
  <tr>
    <td>30</td>
    <td>Normally 0; available for OEM assignment</td>
    <td>Serial Port 2 Resource Conflict</td>
  </tr>
  <tr>
    <td>31</td>
    <td>Normally 0; available for OEM assignment</td>
    <td>Audio Resource Conflict</td>
  </tr>
</table>

3.3.16.6.3.2 System Management Types

The following table defines the system management types present in event log record’s variable data. In general, each type is associated with a management event that occurred within the system.

<table>
  <tr>
    <th>Value</th>
    <th>Name</th>
  </tr>
</table>
<table>
  <tr>
    <th>Value</th>
    <th>Name</th>
  </tr>
  <tr>
    <td>00000000h</td>
    <td>+2.5V Out of range, #1</td>
  </tr>
  <tr>
    <td>00000001h</td>
    <td>+2.5V Out of range, #2</td>
  </tr>
  <tr>
    <td>00000002h</td>
    <td>+3.3V Out of range</td>
  </tr>
  <tr>
    <td>00000003h</td>
    <td>+5V Out of range</td>
  </tr>
  <tr>
    <td>00000004h</td>
    <td>-5V Out of range</td>
  </tr>
  <tr>
    <td>00000005h</td>
    <td>+12V Out of range</td>
  </tr>
  <tr>
    <td>00000006h</td>
    <td>-12V Out of range</td>
  </tr>
  <tr>
    <td>00000007h - 0000000Fh</td>
    <td>Reserved for future out-of-range voltage levels, assigned via this specification</td>
  </tr>
  <tr>
    <td>00000010h</td>
    <td>System board temperature out of range</td>
  </tr>
  <tr>
    <td>00000011h</td>
    <td>Processor #1 temperature out of range</td>
  </tr>
  <tr>
    <td>00000012h</td>
    <td>Processor #2 temperature out of range</td>
  </tr>
  <tr>
    <td>00000013h</td>
    <td>Processor #3 temperature out of range</td>
  </tr>
  <tr>
    <td>00000014h</td>
    <td>Processor #4 temperature out of range</td>
  </tr>
  <tr>
    <td>00000015h - 0000001Fh</td>
    <td>Reserved for future out-of-range temperatures, assigned via this specification</td>
  </tr>
  <tr>
    <td>00000020h - 00000027h</td>
    <td>Fan n (n = 0 to 7) Out of range</td>
  </tr>
  <tr>
    <td>00000028h - 0000002Fh</td>
    <td>Reserved for future assignment via this specification</td>
  </tr>
  <tr>
    <td>00000030h</td>
    <td>Chassis secure switch activated</td>
  </tr>
  <tr>
    <td>00000031h - 0000FFFFh</td>
    <td>Reserved for future assignment via this specification</td>
  </tr>
  <tr>
    <td>0001xxxxh</td>
    <td>A system-management probe or cooling device is out-of-range. The xxxx portion of the value contains the handle of the SMBIOS structure associated with the errant device.</td>
  </tr>
  <tr>
    <td>00020000h - 7FFFFFFFh</td>
    <td>Reserved for future assignment via this specification</td>
  </tr>
  <tr>
    <td>80000000h - FFFFFFFFh</td>
    <td>OEM assigned</td>
  </tr>
</table>

3.3.17 Physical Memory Array (Type 16)

This structure describes a collection of memory devices that operate together to form a memory address space.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>16</td>
    <td>Physical Memory Array type</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>0Fh</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Location</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The physical location of the Memory Array, whether on the system board or an add-in board. See 3.3.17.1 for definitions.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.1+</td>
    <td>Use</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the function for which the array is used. See 3.3.17.2 for definitions.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.1+</td>
    <td>Memory Error Correction</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The primary hardware error correction or detection method supported by this memory array. See 3.3.17.3 for definitions.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.1+</td>
    <td>Maximum Capacity</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The maximum memory capacity, in kilobytes, for this array. If the capacity is unknown, this field contains 8000 0000h.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.1+</td>
    <td>Memory Error Information Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with any error that was previously detected for the array. If the system does not provide the error information structure, the field contains FFFFh; otherwise, the field contains either FFFFh (if no error was detected) or the handle of the error-information structure. See also 3.3.19 32-bit Memory Error Information (Type 18) on page 74 and 3.3.34 64-bit Memory Error Information (Type 33) on page 87.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>2.1+</td>
    <td>Number of Memory Devices</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The number of slots or sockets available for Memory Devices in this array. This value represents the number of Memory Device structures that comprise this Memory Array. Each Memory Device has a reference to the 'owning' Memory Array.</td>
  </tr>
</table>

3.3.17.1 Memory Array — Location

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>System board or motherboard</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>ISA add-on card</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>EISA add-on card</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>PCI add-on card</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>MCA add-on card</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>PCMCIA add-on card</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Proprietary add-on card</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>NuBus</td>
  </tr>
  <tr>
    <td>A0h</td>
    <td>PC-98/C20 add-on card</td>
  </tr>
  <tr>
    <td>A1h</td>
    <td>PC-98/C24 add-on card</td>
  </tr>
  <tr>
    <td>A2h</td>
    <td>PC-98/E add-on card</td>
  </tr>
  <tr>
    <td>A3h</td>
    <td>PC-98/Local bus add-on card</td>
  </tr>
</table>

3.3.17.2 Memory Array — Use

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>System memory</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Video memory</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Flash memory</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Non-volatile RAM</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Cache memory</td>
  </tr>
</table>

3.3.17.3 Memory Array — Error Correction Types

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>None</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Parity</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Single-bit ECC</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Multi-bit ECC</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>CRC</td>
  </tr>
</table>
3.3.18 Memory Device (Type 17)

This structure describes a single memory device that is part of a larger Physical Memory Array (Type 16).

Note: If a system includes memory-device sockets, the SMBIOS implementation includes a Memory Device structure instance for each slot whether or not the socket is currently populated.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>17</td>
    <td>Memory Device type</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, a minimum of 15h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Physical Memory Array Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the Physical Memory Array to which this device belongs.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.1+</td>
    <td>Memory Error Information Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with any error that was previously detected for the device. If the system does not provide the error information structure, the field contains FFFEh; otherwise, the field contains either FFFFh (if no error was detected) or the handle of the error-information structure. See 3.3.19 32-bit Memory Error Information (Type 18) on page 74 and 3.3.34 64-bit Memory Error Information (Type 33) on page 87.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.1+</td>
    <td>Total Width</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The total width, in bits, of this memory device, including any check or error-correction bits. If there are no error-correction bits, this value should be equal to Data Width. If the width is unknown, the field is set to FFFFh.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>2.1+</td>
    <td>Data Width</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The data width, in bits, of this memory device. A Data Width of 0 and a Total Width of 8 indicates that the device is being used solely to provide 8 error-correction bits. If the width is unknown, the field is set to FFFFh.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.1+</td>
    <td>Size</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The size of the memory device. If the value is 0, no memory device is installed in the socket; if the size is unknown, the field value is FFFFh.<br><br>The granularity in which the value is specified depends on the setting of the most-significant bit (bit 15). If the bit is 0, the value is specified in megabyte units; if the bit is 1, the value is specified in kilobyte units. For example, the value 8100h identifies a 256KB memory device and 0100h identifies a 256MB memory device.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>2.1+</td>
    <td>Form Factor</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The implementation form factor for this memory device. See 3.3.18.1 for definitions.</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>2.1+</td>
    <td>Device Set</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies when the Memory Device is one of a set of Memory Devices that must be populated with all devices of the same type and size, and the set to which this device belongs. A value of 0 indicates that the device is not part of a set; a value of FFh indicates that the attribute is unknown.<br><br><i>Note:</i> A Device Set number must be unique within the context of the Memory Array containing this Memory Device.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>2.1+</td>
    <td>Device Locator</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The string number of the string that identifies the physically-labeled socket or board position where the memory device is located, e.g. "SIMM 3".</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>11h</td>
    <td>2.1+</td>
    <td>Bank Locator</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The string number of the string that identifies the physically labeled bank where the memory device is located, e.g. “Bank 0” or “A”.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>2.1+</td>
    <td>Memory Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The type of memory used in this device; see 3.3.18.2 for definitions.</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>2.1+</td>
    <td>Type Detail</td>
    <td>WORD</td>
    <td>Bit Field</td>
    <td>Additional detail on the memory device type, see 3.3.18.3 for definitions.</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>2.3+</td>
    <td>Speed</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Identifies the speed of the device, in megahertz (MHz). If the value is 0, the speed is unknown.<br><b>Note:</b> \( n \) MHz = (1000 / \( n \)) nanoseconds (ns)</td>
  </tr>
  <tr>
    <td>17h</td>
    <td>2.3+</td>
    <td>Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the manufacturer of this memory device.</td>
  </tr>
  <tr>
    <td>18h</td>
    <td>2.3+</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the serial number of this memory device. This value is set by the manufacturer and normally not changeable.</td>
  </tr>
  <tr>
    <td>19h</td>
    <td>2.3+</td>
    <td>Asset Tag</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the asset tag of this memory device.</td>
  </tr>
  <tr>
    <td>1Ah</td>
    <td>2.3+</td>
    <td>Part Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>String number for the part number of this memory device. This value is set by the manufacturer and normally not changeable.</td>
  </tr>
</table>

3.3.18.1 Memory Device — Form Factor

<b>Important Note:</b> Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>SIMM</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>SIP</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Chip</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>DIP</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>ZIP</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Proprietary Card</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>DIMM</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>TSOP</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Row of chips</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>RIMM</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>SODIMM</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>SRIMM</td>
  </tr>
</table>

3.3.18.2 Memory Device — Type

<b>Important Note:</b> Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>DRAM</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>EDRAM</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>VRAM</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>SRAM</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>RAM</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>ROM</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>FLASH</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>EEPROM</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>FEPROM</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>EPROM</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>CDRAM</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>3DRAM</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>SDRAM</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>SGRAM</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>RDRAM</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>DDR</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>DDR2</td>
  </tr>
</table>

3.3.18.3 Memory Device — Type Detail

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

Note: Multiple bits are set if more than one attribute applies.

<table>
  <tr>
    <th>Word Bit Position</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>Bit 0</td>
    <td>Reserved, set to 0.</td>
  </tr>
  <tr>
    <td>Bit 1</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>Bit 2</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>Bit 3</td>
    <td>Fast-paged</td>
  </tr>
  <tr>
    <td>Bit 4</td>
    <td>Static column</td>
  </tr>
  <tr>
    <td>Bit 5</td>
    <td>Pseudo-static</td>
  </tr>
  <tr>
    <td>Bit 6</td>
    <td>RAMBUS</td>
  </tr>
  <tr>
    <td>Bit 7</td>
    <td>Synchronous</td>
  </tr>
  <tr>
    <td>Bit 8</td>
    <td>CMOS</td>
  </tr>
  <tr>
    <td>Bit 9</td>
    <td>EDO</td>
  </tr>
  <tr>
    <td>Bit 10</td>
    <td>Window DRAM</td>
  </tr>
  <tr>
    <td>Bit 11</td>
    <td>Cache DRAM</td>
  </tr>
  <tr>
    <td>Bit 12</td>
    <td>Non-volatile</td>
  </tr>
  <tr>
    <td>Bits 13:15</td>
    <td>Reserved, set to 0.</td>
  </tr>
</table>

3.3.19 32-bit Memory Error Information (Type 18)

This structure identifies the specifics of an error that might be detected within a Physical Memory Array.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>18</td>
    <td>32-bit Memory Error Information type</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>17h</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Error Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The type of error that is associated with the current status reported for the memory array or device. See 3.3.19.1 for definitions..</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.1+</td>
    <td>Error Granularity</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the granularity, e.g. device vs. Partition, to which the error can be resolved. See 3.3.19.2 for definitions.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.1+</td>
    <td>Error Operation</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The memory access operation that caused the error. See 3.3.19.3 for definitions.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.1+</td>
    <td>Vendor Syndrome</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The vendor-specific ECC syndrome or CRC data associated with the erroneous access. If the value is unknown, this field contains 0000 0000h.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>2.1+</td>
    <td>Memory Array Error Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The 32-bit physical address of the error based on the addressing of the bus to which the memory array is connected. If the address is unknown, this field contains 8000 0000h.</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>2.1+</td>
    <td>Device Error Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The 32-bit physical address of the error relative to the start of the failing memory device, in bytes. If the address is unknown, this field contains 8000 0000h.</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>2.1+</td>
    <td>Error Resolution</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The range, in bytes, within which the error can be determined, when an error address is given. If the range is unknown, this field contains 8000 0000h.</td>
  </tr>
</table>

3.3.19.1 Memory Error — Error Type

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>OK</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Bad read</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Parity error</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Single-bit error</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Double-bit error</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Multi-bit error</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Nibble error</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Checksum error</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>CRC error</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Corrected single-bit error</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Corrected error</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Uncorrectable error</td>
  </tr>
</table>

3.3.19.2 Memory Error — Error Granularity

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Device level</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Memory partition level</td>
  </tr>
</table>

3.3.19.3 Memory Error — Error Operation

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Read</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Write</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Partial write</td>
  </tr>
</table>
3.3.20 Memory Array Mapped Address (Type 19)

This structure provides the address mapping for a Physical Memory Array. One structure is present for each contiguous address range described.

See also 3.3.17 Physical Memory Array (Type 16) on page 70, 3.3.18 Memory Device (Type 17) on page 72, and 3.3.21 Memory Device Mapped Address (Type 20) on page 76.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>19</td>
    <td>Memory Array Mapped Address indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>0Fh</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Starting Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The physical address, in kilobytes, of a range of memory mapped to the specified <i>Physical Memory Array</i>.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.1+</td>
    <td>Ending Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The physical ending address of the last kilobyte of a range of addresses mapped to the specified <i>Physical Memory Array</i>.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.1+</td>
    <td>Memory Array Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the <i>Physical Memory Array</i> to which this address range is mapped. Multiple address ranges can be mapped to a single <i>Physical Memory Array</i>.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>2.1+</td>
    <td>Partition Width</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the number of <i>Memory Devices</i> that form a single row of memory for the address partition defined by this structure.</td>
  </tr>
</table>

3.3.21 Memory Device Mapped Address (Type 20)

This structure maps memory address space usually to a device-level granularity. One structure is present for each contiguous address range described.

Note: A Memory Device Mapped Address structure is provided only if a Memory Device has a mapped address — there is no provision within this structure to map a zero-length address space.

See also 3.3.17 Physical Memory Array (Type 16) on page 70, 3.3.18 Memory Device (Type 17) on page 72, and 3.3.20 Memory Array Mapped Address (Type 19) on page 76.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>20</td>
    <td>Memory Device Mapped Address indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>13h</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Starting Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The physical address, in kilobytes, of a range of memory mapped to the referenced <i>Memory Device</i>.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.1+</td>
    <td>Ending Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The physical ending address of the last kilobyte of a range of addresses mapped to the referenced <i>Memory Device</i>.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.1+</td>
    <td>Memory Device Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the <i>Memory Device</i> structure to which this address range is mapped. Multiple address ranges can be mapped to a single <i>Memory Device</i>.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>2.1+</td>
    <td>Memory Array Mapped Address Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the <i>Memory Array Mapped Address</i> structure to which this device address range is mapped. Multiple address ranges can be mapped to a single <i>Memory Array Mapped Address</i>.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>10h</td>
    <td>2.1+</td>
    <td>Partition Row Position</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the position of the referenced Memory Device in a row of the address partition. For example, if two 8-bit devices form a 16-bit row, this field’s value will be either 1 or 2.<br>The value 0 is reserved; if the position is unknown, the field contains FFh.</td>
  </tr>
  <tr>
    <td>11h</td>
    <td>2.1+</td>
    <td>Interleave Position</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The position of the referenced Memory Device in an interleave. The value 0 indicates non-interleaved, 1 indicates first interleave position, 2 the second, and so on. If the position is unknown, the field contains FFh.<br>For example: in a 2:1 interleave, the value 1 indicates the device in the ‘even’ position; in a 4:1 interleave, the value 1 indicates the first of four possible positions.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>2.1+</td>
    <td>Interleaved Data Depth</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The maximum number of consecutive rows from the referenced Memory Device that are accessed in a single interleaved transfer. If the device is not part of an interleave, the field contains 0; if the interleave configuration is unknown, the value is FFh.<br>For example, if a device transfers two rows each time it is read, its Interleaved Data Depth is set to 2. If that device is 2:1 interleaved and in Interleave Position 1, the rows mapped to that device are 1, 2, 5, 6, 9, 10, etc.</td>
  </tr>
</table>

3.3.22 Built-in Pointing Device (Type 21)

This structure describes the attributes of the built-in pointing device for the system — the presence of this structure does not imply that the built-in pointing device is active for the system’s use!

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>21</td>
    <td>Built-in Pointing Device indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>07h</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The type of pointing device, see 3.3.22.1.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.1+</td>
    <td>Interface</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The interface type for the pointing device, see 3.3.22.2.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.1+</td>
    <td>Number of Buttons</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The number of buttons on the pointing device. If the device has three buttons, the field value is 03h.</td>
  </tr>
</table>

3.3.22.1 Pointing Device — Type

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Mouse</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Track Ball</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Track Point</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Glide Point</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>07h</td>
    <td>Touch Pad</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Touch Screen</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Optical Sensor</td>
  </tr>
</table>

3.3.22.2 Pointing Device — Interface

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Serial</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>PS/2</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Infrared</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>HP-HIL</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Bus mouse</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>ADB (Apple Desktop Bus)</td>
  </tr>
  <tr>
    <td>A0h</td>
    <td>Bus mouse DB-9</td>
  </tr>
  <tr>
    <td>A1h</td>
    <td>Bus mouse micro-DIN</td>
  </tr>
  <tr>
    <td>A2h</td>
    <td>USB</td>
  </tr>
</table>

3.3.23 Portable Battery (Type 22)

This structure describes the attributes of the portable battery(s) for the system. The structure contains the static attributes for the group. Each structure describes a single battery pack’s attributes.

<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>2.1+</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>22</td>
    <td>Portable Battery indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>2.1+</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>1Ah</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>2.1+</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>2.1+</td>
    <td>Location</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that identifies the location of the battery, e.g. “in the back, on the left-hand side.”</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>2.1+</td>
    <td>Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that names the company that manufactured the battery.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>2.1+</td>
    <td>Manufacture Date</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that identifies the date on which the battery was manufactured. V2.2+ implementations that use a Smart Battery will set this field to 0 (no string) to indicate that the SBDS Manufacture Date field contains the information.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>2.1+</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains the serial number for the battery. V2.2+ implementations that use a Smart Battery will set this field to 0 (no string) to indicate that the SBDS Serial Number field contains the information.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>2.1+</td>
    <td>Device Name</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that names the battery device, e.g. “DR-36”.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>2.1+</td>
    <td>Device Chemistry</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the battery chemistry, see 3.3.23.1. V2.2+ implementations that use a Smart Battery will set this field to 02h (Unknown) to indicate that the SBDS Device Chemistry field contains the information.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Spec Version</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>2.1+</td>
    <td>Design Capacity</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The design capacity of the battery in mWatt-hours. If the value is unknown, the field contains 0. For v2.2+ implementations, this value is multiplied by the <i>Design Capacity Multiplier</i> to produce the actual value.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>2.1+</td>
    <td>Design Voltage</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The design voltage of the battery, in mVolts. If the value is unknown, the field contains 0.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>2.1+</td>
    <td>SBDS Version Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains the <i>Smart Battery Data Specification</i> version number supported by this battery. If the battery does not support the function, no string is supplied.</td>
  </tr>
  <tr>
    <td>0Fh</td>
    <td>2.1+</td>
    <td>Maximum Error in Battery Data</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The maximum error (as a percentage in the range 0 to 100) in the Watt-hour data reported by the battery, indicating an upper bound on how much additional energy the battery might have above the energy it reports having. If the value is unknown, the field contains FFh.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>2.2+</td>
    <td>SBDS Serial Number</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The 16-bit value that identifies the battery’s serial number. This value, when combined with the Manufacturer, Device Name, and Manufacture Date will uniquely identify the battery. The <i>Serial Number</i> field must be set to 0 (no string) for this field to be valid.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>2.2+</td>
    <td>SBDS Manufacture Date</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The date the cell pack was manufactured, in packed format:<br>Bits 15:9 Year, biased by 1980, in the range 0 to 127.<br>Bits 8:5 Month, in the range 1 to 12.<br>Bits 4:0 Date, in the range 1 to 31.<br><br>For example, 01 February 2000 would be identified as 0010 1000 0100 0001b (0x2841).<br>The <i>Manufacture Date</i> field must be set to 0 (no string) to for this field to be valid.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>2.2+</td>
    <td>SBDS Device Chemistry</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that identifies the battery chemistry, e.g. “PbAc”. The <i>Device Chemistry</i> field must be set to 02h (<i>Unknown</i>) for this field to be valid.</td>
  </tr>
  <tr>
    <td>15h</td>
    <td>2.2+</td>
    <td>Design Capacity Multiplier</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The multiplication factor of the <i>Design Capacity</i> value and assures that the mWatt hours value does not overflow for SBDS implementations. The multiplier default is 1, SBDS implementations use the value 10 to correspond to the data as returned from the SBDS Function 18h.</td>
  </tr>
  <tr>
    <td>16h</td>
    <td>2.2+</td>
    <td>OEM-specific</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>Contains OEM- or BIOS vendor-specific information.</td>
  </tr>
</table>

3.3.23.1 Portable Battery — Device Chemistry

<b>Important Note:</b> Refer to 3.3 for the CIM and DMI attributes associated with this enumerated value.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>Lead Acid</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Nickel Cadmium</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Nickel metal hydride</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Lithium-ion</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>07h</td>
    <td>Zinc air</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Lithium Polymer</td>
  </tr>
</table>

3.3.24 System Reset (Type 23)

This structure describes whether Automatic System Reset functions enabled (Status). If the system has a watchdog Timer and the timer is not reset (Timer Reset) before the Interval elapses, an automatic system reset will occur. The system will re-boot according to the Boot Option. This function may repeat until the Limit is reached, at which time the system will re-boot according to the Boot Option at Limit.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>23</td>
    <td>System Reset indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>0Dh</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Capabilities</td>
    <td>BYTE</td>
    <td>Bit-field</td>
    <td>Identifies the system-reset capabilities for the system.<br>Bits 7:6 Reserved for future assignment via this specification, set to 00b.<br>Bit 5 System contains a watchdog timer, either True (1) or False (0).<br>Bits 4:3 <i>Boot Option on Limit</i>. Identifies the system action to be taken when the Reset Limit is reached, one of:<br>00b Reserved, do not use.<br>01b Operating system<br>10b System utilities<br>11b Do not reboot<br>Bits 2:1 <i>Boot Option</i>. Indicates the action to be taken following a watchdog reset, one of:<br>00b Reserved, do not use.<br>01b Operating system<br>10b System utilities<br>11b Do not reboot<br>Bit 0 <i>Status</i>. Identifies whether (1) or not (0) the system reset is enabled by the user.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Reset Count</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The number of automatic system resets since the last intentional reset. A value of OFFFFh indicates unknown.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Reset Limit</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The number of consecutive times the system reset will be attempted. A value of OFFFFh indicates unknown.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Timer Interval</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The number of minutes to use for the watchdog timer. If the timer is not reset within this interval, the system reset timeout will begin. A value of OFFFFh indicates unknown.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Timeout</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Identifies the number of minutes before the reboot is initiated. It is used after a system power cycle, system reset (local or remote), and automatic system reset. A value of OFFFFh indicates unknown.</td>
  </tr>
</table>

3.3.25 Hardware Security (Type 24)

This structure describes the system-wide hardware security settings.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>24</td>
    <td>Hardware Security indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>05h</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>04h</td>
    <td>Hardware Security Settings</td>
    <td>BYTE</td>
    <td>Bit-field</td>
    <td>Identifies the password and reset status for the system:<br>Bits 7:6<br><i>Power-on Password Status</i>, one of:<br>00b Disabled<br>01b Enabled<br>10b Not Implemented<br>11b Unknown<br>Bits 5:4<br><i>Keyboard Password Status</i>, one of:<br>00b Disabled<br>01b Enabled<br>10b Not Implemented<br>11b Unknown<br>Bits 3:2<br><i>Administrator Password Status</i>, one of:<br>00b Disabled<br>01b Enabled<br>10b Not Implemented<br>11b Unknown<br>Bits 1:0<br><i>Front Panel Reset Status</i>, one of:<br>00b Disabled<br>01b Enabled<br>10b Not Implemented<br>11b Unknown</td>
  </tr>
</table>

3.3.26 System Power Controls (Type 25)

This structure describes the attributes for controlling the main power supply to the system. Software that interprets this structure uses the month, day, hour, minute, and second values to determine the number of seconds until the next power-on of the system. The presence of this structure implies that a timed power-on facility is available for the system.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>25</td>
    <td>System Power Controls indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>09h</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Next Scheduled Power-on Month</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Contains the BCD value of the month on which the next scheduled power-on is to occur, in the range 01h to 12h. See 3.3.26.1.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Next Scheduled Power-on Day-of-month</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Contains the BCD value of the day-of-month on which the next scheduled power-on is to occur, in the range 01h to 31h. See 3.3.26.1.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Next Scheduled Power-on Hour</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Contains the BCD value of the hour on which the next scheduled power-on is to occur, in the range 00h to 23h. See 3.3.26.1.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Next Scheduled Power-on Minute</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Contains the BCD value of the minute on which the next scheduled power-on is to occur, in the range 00h to 59h. See 3.3.26.1.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Next Scheduled Power-on Second</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Contains the BCD value of the second on which the next scheduled power-on is to occur, in the range 00h to 59h. See 3.3.26.1.</td>
  </tr>
</table>

3.3.26.1 System Power Controls — Calculating the Next Scheduled Power-on Time

The DMTF System Power Controls group contains a Next Scheduled Power-on Time, specified as the number of seconds until the next scheduled power-on of the system. Management software uses the date and time information specified in the associated SMBIOS structure to calculate the total number of seconds.
Any date or time field in the structure whose value is outside of the field’s specified range does not contribute to the total-seconds count. For example, if the Month field contains the value 0xFF the next power-on is scheduled to fall within the next month, perhaps on a specific day-of-month and time.

3.3.27 Voltage Probe (Type 26)

This describes the attributes for a voltage probe in the system. Each structure describes a single voltage probe.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>26</td>
    <td>Voltage Probe indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, at least 14h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Description</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains additional descriptive information about the probe or its location.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Location and Status</td>
    <td>BYTE</td>
    <td>Bit-field</td>
    <td>Defines the probe’s physical location and status of the voltage monitored by this voltage probe. See 3.3.27.1.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Maximum Value</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The maximum voltage level readable by this probe, in millivolts. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Minimum Value</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The minimum voltage level readable by this probe, in millivolts. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Resolution</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The resolution for the probe’s reading, in tenths of millivolts. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Tolerance</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The tolerance for reading from this probe, in plus/minus millivolts. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Accuracy</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The accuracy for reading from this probe, in plus/minus 1/100th of a percent. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>OEM-defined</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>Contains OEM- or BIOS vendor-specific information.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>Nominal Value</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The nominal value for the probe’s reading in millivolts. If the value is unknown, the field is set to 0x8000. This field is present in the structure only if the structure’s Length is larger than 14h.</td>
  </tr>
</table>

3.3.27.1 Voltage Probe — Location and Status

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with these enumerated values.

<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td rowspan="6">7:5</td>
    <td>Status</td>
    <td>001.....</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td>010.....</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td>011.....</td>
    <td>OK</td>
  </tr>
  <tr>
    <td></td>
    <td>100.....</td>
    <td>Non-critical</td>
  </tr>
  <tr>
    <td></td>
    <td>101.....</td>
    <td>Critical</td>
  </tr>
  <tr>
    <td></td>
    <td>110.....</td>
    <td>Non-recoverable</td>
  </tr>
  <tr>
    <td rowspan="9">4:0</td>
    <td>Location</td>
    <td>...00001</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td>...00010</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td>...00011</td>
    <td>Processor</td>
  </tr>
  <tr>
    <td></td>
    <td>...00100</td>
    <td>Disk</td>
  </tr>
  <tr>
    <td></td>
    <td>...00101</td>
    <td>Peripheral Bay</td>
  </tr>
  <tr>
    <td></td>
    <td>...00110</td>
    <td>System Management Module</td>
  </tr>
  <tr>
    <td></td>
    <td>...00111</td>
    <td>Motherboard</td>
  </tr>
  <tr>
    <td></td>
    <td>...01000</td>
    <td>Memory Module</td>
  </tr>
  <tr>
    <td></td>
    <td>...01001</td>
    <td>Processor Module</td>
  </tr>
</table>
<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td colspan="4">...01010</td>
    <td>Power Unit</td>
  </tr>
  <tr>
    <td colspan="4">...01011</td>
    <td>Add-in Card</td>
  </tr>
</table>

3.3.28 Cooling Device (Type 27)

This structure describes the attributes for a cooling device in the system. Each structure describes a single cooling device.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>27</td>
    <td>Cooling Device indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, at least 0Ch.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Temperature Probe Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, of the temperature probe (see 3.3.29 Temperature Probe (Type 28) on page 84) monitoring this cooling device. A value of 0xFFFF indicates that no probe is provided.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Device Type and Status</td>
    <td>BYTE</td>
    <td>Bit-field</td>
    <td>Identifies the cooling device type and the status of this cooling device, see 3.3.28.1.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Cooling Unit Group</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the cooling unit group to which this cooling device is associated. Multiple cooling devices in the same cooling unit implies a redundant configuration. The value is 00h if the cooling device is not a member of a redundant cooling unit, non-zero values imply redundancy and that at least one other cooling device will be enumerated with the same value.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>OEM-defined</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>Contains OEM- or BIOS vendor-specific information.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Nominal Speed</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The nominal value for the cooling device's rotational speed, in revolutions-per-minute (rpm). If the value is unknown or the cooling device is non-rotating, the field is set to 0x8000. This field is present in the structure only if the structure's Length is larger than 0Ch.</td>
  </tr>
</table>

3.3.28.1 Cooling Device —Device Type and Status

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with these enumerated values.

<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>7:5</td>
    <td>Status</td>
    <td>001.....</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>010.....</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>011.....</td>
    <td>OK</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>100.....</td>
    <td>Non-critical</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>101.....</td>
    <td>Critical</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>110.....</td>
    <td>Non-recoverable</td>
  </tr>
  <tr>
    <td>4:0</td>
    <td>Device Type</td>
    <td>..00001</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..00010</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..00011</td>
    <td>Fan</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..00100</td>
    <td>Centrifugal Blower</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..00101</td>
    <td>Chip Fan</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..00110</td>
    <td>Cabinet Fan</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..00111</td>
    <td>Power Supply Fan</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..01000</td>
    <td>Heat Pipe</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..01001</td>
    <td>Integrated Refrigeration</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..10000</td>
    <td>Active Cooling</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>..10001</td>
    <td>Passive Cooling</td>
  </tr>
</table>
3.3.29 Temperature Probe (Type 28)

This structure describes the attributes for a temperature probe in the system. Each structure describes a single temperature probe.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>28</td>
    <td>Temperature Probe indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, at least 14h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Description</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains additional descriptive information about the probe or its location.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Location and Status</td>
    <td>BYTE</td>
    <td>Bit-field</td>
    <td>Defines the probe’s physical location and the status of the temperature monitored by this temperature probe. See 3.3.29.1.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Maximum Value</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The maximum temperature readable by this probe, in 1/10<sup>th</sup> degrees C. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Minimum Value</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The minimum temperature readable by this probe, in 1/10<sup>th</sup> degrees C. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Resolution</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The resolution for the probe’s reading, in 1/1000<sup>th</sup> degrees C. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Tolerance</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The tolerance for reading from this probe, in plus/minus 1/10<sup>th</sup> degrees C. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Accuracy</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The accuracy for reading from this probe, in plus/minus 1/100<sup>th</sup> of a percent. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>OEM-defined</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>Contains OEM- or BIOS vendor-specific information.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>Nominal Value</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The nominal value for the probe’s reading in 1/10<sup>th</sup> degrees C. If the value is unknown, the field is set to 0x8000. This field is present in the structure only if the structure’s <i>Length</i> is larger than 14h.</td>
  </tr>
</table>

3.3.29.1 Temperature Probe — Location and Status

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with these enumerated values.

<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>7:5</td>
    <td>Status</td>
    <td>001.....</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>010.....</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>011.....</td>
    <td>OK</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>100.....</td>
    <td>Non-critical</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>101.....</td>
    <td>Critical</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>110.....</td>
    <td>Non-recoverable</td>
  </tr>
</table>
<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>4:0</td>
    <td>Location</td>
    <td>...00001</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00010</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00011</td>
    <td>Processor</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00100</td>
    <td>Disk</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00101</td>
    <td>Peripheral Bay</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00110</td>
    <td>System Management Module</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00111</td>
    <td>Motherboard</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01000</td>
    <td>Memory Module</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01001</td>
    <td>Processor Module</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01010</td>
    <td>Power Unit</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01011</td>
    <td>Add-in Card</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01100</td>
    <td>Front Panel Board</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01101</td>
    <td>Back Panel Board</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01110</td>
    <td>Power System Board</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01111</td>
    <td>Drive Back Plane</td>
  </tr>
</table>

3.3.30 Electrical Current Probe (Type 29)

This structure describes the attributes for an electrical current probe in the system. Each structure describes a single electrical current probe.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>29 Electrical Current Probe indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies Length of the structure, at least 14h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Description</td>
    <td>BYTE</td>
    <td>STRING The number of the string that contains additional descriptive information about the probe or its location.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Location and Status</td>
    <td>BYTE</td>
    <td>ENUM Defines the probe’s physical location and the status of the current monitored by this current probe. See 3.3.30.1.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Maximum Value</td>
    <td>WORD</td>
    <td>Varies The maximum current readable by this probe, in milliamps. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Minimum Value</td>
    <td>WORD</td>
    <td>Varies The minimum current readable by this probe, in milliamps. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Resolution</td>
    <td>WORD</td>
    <td>Varies The resolution for the probe’s reading, in tenths of milliamps. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Tolerance</td>
    <td>WORD</td>
    <td>Varies The tolerance for reading from this probe, in plus/minus milliamps. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Accuracy</td>
    <td>WORD</td>
    <td>Varies The accuracy for reading from this probe, in plus/minus 1/100th of a percent. If the value is unknown, the field is set to 0x8000.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>OEM-defined</td>
    <td>DWORD</td>
    <td>Varies Contains OEM- or BIOS vendor-specific information.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>Nominal Value</td>
    <td>WORD</td>
    <td>Varies The nominal value for the probe’s reading in milliamps. If the value is unknown, the field is set to 0x8000. This field is present in the structure only if the structure’s Length is larger than 14h.</td>
  </tr>
</table>

3.3.30.1 Current Probe — Location and Status

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with these enumerated values.

<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>7:5</td>
    <td>Status</td>
    <td>001.....</td>
    <td>Other</td>
  </tr>
</table>
<table>
  <tr>
    <th>Bit Range</th>
    <th>Field Name</th>
    <th>Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td colspan="4">010..... Unknown</td>
  </tr>
  <tr>
    <td colspan="4">011..... OK</td>
  </tr>
  <tr>
    <td colspan="4">100..... Non-critical</td>
  </tr>
  <tr>
    <td colspan="4">101..... Critical</td>
  </tr>
  <tr>
    <td colspan="4">110..... Non-recoverable</td>
  </tr>
  <tr>
    <td>4:0</td>
    <td>Location</td>
    <td>...00001</td>
    <td>Other</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00010</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00011</td>
    <td>Processor</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00100</td>
    <td>Disk</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00101</td>
    <td>Peripheral Bay</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00110</td>
    <td>System Management Module</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...00111</td>
    <td>Motherboard</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01000</td>
    <td>Memory Module</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01001</td>
    <td>Processor Module</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01010</td>
    <td>Power Unit</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...01011</td>
    <td>Add-in Card</td>
  </tr>
</table>

3.3.31 Out-of-Band Remote Access (Type 30)

This structure describes the attributes and policy settings of a hardware facility that may be used to gain remote access to a hardware system when the operating system is not available due to power-down status, hardware failures, or boot failures.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>30</td>
    <td>Out-of-Band Remote Access indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>06h</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Manufacturer Name</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains the manufacturer of the out-of-band access facility.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Connections</td>
    <td>BYTE</td>
    <td>Bit-field</td>
    <td>
      Identifies the current remote-access connections:<br>
      Bits 7:2 Reserved for future definition by this specification, set to all zeros.<br>
      Bit 1 <i>Outbound Connection Enabled.</i> Identifies whether (1) or not (0) the facility is allowed to initiate outbound connections to contact an alert management facility when critical conditions occur.<br>
      Bit 0 <i>Inbound Connection Enabled.</i> Identifies whether (1) or not (0) the facility is allowed to initiate outbound connections to receive incoming connections for the purpose of remote operations or problem management
    </td>
  </tr>
</table>

3.3.32 Boot Integrity Services (BIS) Entry Point (Type 31)

Structure type 31 (decimal) is reserved for use by the Boot Integrity Services (BIS). Refer to the <i>Boot Integrity Services API Specification</i> for content details.

Note: This structure type was added for specification v2.3.
3.3.33 System Boot Information (Type 32)

The client system firmware, e.g. BIOS, communicates the System Boot Status to the client’s Pre-boot Execution Environment (PXE) boot image or OS-present management application via this structure. When used in the PXE environment, for example, this code identifies the reason the PXE was initiated and can be used by boot-image software to further automate an enterprise’s PXE sessions. For example, an enterprise could choose to automatically download a hardware-diagnostic image to a client whose reason code indicated either a firmware- or operating system-detected hardware failure.

Note: This structure type was added for specification v2.3.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>32</td>
    <td>System Boot Information structure identifier</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, in bytes; at least 0Bh.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Reserved</td>
    <td>6 BYTES</td>
    <td>00h</td>
    <td>Reserved for future assignment via this specification, all bytes are set to 00h.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Boot Status</td>
    <td><i>Length-10 Bytes</i></td>
    <td>Varies</td>
    <td>The Status and Additional Data fields that identify the boot status. See 3.3.33.1 for additional information.</td>
  </tr>
</table>

3.3.33.1 System Boot Status

<table>
  <tr>
    <th>Description</th>
    <th>Status</th>
    <th>Additional Data</th>
  </tr>
  <tr>
    <td>No errors detected</td>
    <td>0</td>
    <td>None</td>
  </tr>
  <tr>
    <td>No bootable media</td>
    <td>1</td>
    <td>none</td>
  </tr>
  <tr>
    <td>The “normal” operating system failed to load.</td>
    <td>2</td>
    <td>none</td>
  </tr>
  <tr>
    <td>Firmware-detected hardware failure, including “unknown” failure types.</td>
    <td>3</td>
    <td>none</td>
  </tr>
  <tr>
    <td>Operating system-detected hardware failure. For ACPI OS’s, the system firmware might set this reason code when the OS reports a boot failure via interfaces defined in the <i>Simple Boot Flag Specification</i>.</td>
    <td>4</td>
    <td>none</td>
  </tr>
  <tr>
    <td>User-requested boot, usually via a keystroke</td>
    <td>5</td>
    <td>none</td>
  </tr>
  <tr>
    <td>System security violation</td>
    <td>6</td>
    <td>none</td>
  </tr>
  <tr>
    <td>Previously-requested image. This reason code allows coordination between OS-present software and the OS-absent environment. For example, an OS-present application might enable (via a platform-specific interface) the system to boot to the PXE and request a specific boot-image.</td>
    <td>7</td>
    <td>varies</td>
  </tr>
  <tr>
    <td>A system watchdog timer expired, causing the system to reboot.</td>
    <td>8</td>
    <td>none</td>
  </tr>
  <tr>
    <td>Reserved for future assignment via this specification.</td>
    <td>9-127</td>
    <td>Varies</td>
  </tr>
  <tr>
    <td>Vendor/OEM-specific implementations. The Vendor/OEM identifier is the “Manufacturer” string found in the <i>System Identification</i> structure.</td>
    <td>128-191</td>
    <td>Varies</td>
  </tr>
  <tr>
    <td>Product-specific implementations. The product identifier is formed by the concatenation of the “Manufacturer” and “Product Name” strings found in the <i>System Information</i> structure.</td>
    <td>192-255</td>
    <td>Varies</td>
  </tr>
</table>

3.3.34 64-bit Memory Error Information (Type 33)

This structure describes an error within a Physical Memory Array, when the error address is above 4G (0xFFFFFFFF).

Note: This structure type was added for specification v2.3.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>33</td>
    <td>64-bit Memory Error Information type</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>1Fh</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>04h</td>
    <td>Error Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The type of error that is associated with the current status reported for the memory array or device. See 3.3.19.1 for definitions.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Error Granularity</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Identifies the granularity, e.g. device vs. Partition, to which the error can be resolved. See 3.3.19.2 for definitions.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Error Operation</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>The memory access operation that caused the error. See 3.3.19.3 for definitions.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Vendor Syndrome</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The vendor-specific ECC syndrome or CRC data associated with the erroneous access. If the value is unknown, this field contains 0000 0000h.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Memory Array Error Address</td>
    <td>QWORD</td>
    <td>Varies</td>
    <td>The 64-bit physical address of the error based on the addressing of the bus to which the memory array is connected. If the address is unknown, this field contains 8000 0000 0000 0000h.</td>
  </tr>
  <tr>
    <td>13h</td>
    <td>Device Error Address</td>
    <td>QWORD</td>
    <td>Varies</td>
    <td>The 64-bit physical address of the error relative to the start of the failing memory device, in bytes. If the address is unknown, this field contains 8000 0000 0000 0000h.</td>
  </tr>
  <tr>
    <td>1Bh</td>
    <td>Error Resolution</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>The range, in bytes, within which the error can be determined, when an error address is given. If the range is unknown, this field contains 8000 0000h.</td>
  </tr>
</table>

3.3.35 Management Device (Type 34)

The information in this structure defines the attributes of a Management Device. A Management Device might control one or more fans or voltage, current, or temperature probes as defined by one or more Management Device Component structures — see 3.3.36 Management Device Component (Type 35) on page 89.

Note: This structure type was added for specification v2.3.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>34</td>
    <td>Management Device indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>0Bh</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Description</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains additional descriptive information about the device or its location.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Defines the device’s type, see 3.3.35.1</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Address</td>
    <td>DWORD</td>
    <td>Varies</td>
    <td>Defines the device’s address</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Address Type</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Defines the type of addressing used to access the device, see 3.3.35.2.</td>
  </tr>
</table>

3.3.35.1 Management Device — Type

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>National Semiconductor LM75</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>National Semiconductor LM78</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>National Semiconductor LM79</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>National Semiconductor LM80</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>National Semiconductor LM81</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Analog Devices ADM9240</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Dallas Semiconductor DS1780</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Maxim 1617</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Genesys GL518SM</td>
  </tr>
</table>
<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Winbond W83781D</td>
  </tr>
  <tr>
    <td>0Dh</td>
    <td>Holtek HT82H791</td>
  </tr>
</table>

3.3.35.2 Management Device — Address Type

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>I/O Port</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Memory</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>SM Bus</td>
  </tr>
</table>

3.3.36 Management Device Component (Type 35)

This structure associates a cooling device or environmental probe with structures that define the controlling hardware device and (optionally) the component’s thresholds.

Note: This structure type was added for specification v2.3.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>35</td>
    <td>Management Device Component indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>0Bh</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Description</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains additional descriptive information about the component.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Management Device Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, of the Management Device — see 3.3.35 Management Device (Type 34) on page 88 — that contains this component.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Component Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, of the probe or cooling device that defines this component. See 3.3.27 Voltage Probe (Type 26) on page 82, 3.3.28 Cooling Device (Type 27) on page 83, 3.3.29 Temperature Probe (Type 28) on page 84, and 3.3.30 Electrical Current Probe (Type 29) on page 85.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Threshold Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the device thresholds — see 3.3.37 Management Device Threshold Data (Type 36) on page 89. A value of 0FFFFh indicates that no Threshold Data structure is associated with this component.</td>
  </tr>
</table>

3.3.37 Management Device Threshold Data (Type 36)

The information in this structure defines threshold information for a component (probe or cooling-unit) contained within a Management Device.

For each threshold field present in the structure:

• The threshold units (millivolts, milliamps, 1/10\(^{th}\) degrees C, or RPMs) are as defined by the associated probe or cooling-unit component structure

• If the value is unavailable, the field is set to 0x8000.

Note: This structure type was added for specification v2.3.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>36</td>
    <td>Management Device Threshold Data structure indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>10h</td>
    <td>Length of the structure.</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Lower Threshold – Non-critical</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The lower non-critical threshold for this component</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Upper Threshold – Non-critical</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The upper non-critical threshold for this component</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Lower Threshold – Critical</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The lower critical threshold for this component</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Upper Threshold – Critical</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The upper critical threshold for this component</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Lower Threshold – Non-recoverable</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The lower non-recoverable threshold for this component</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Upper Threshold – Non-recoverable</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The upper non-recoverable threshold for this component</td>
  </tr>
</table>

3.3.38 Memory Channel (Type 37)

The information in this structure provides the correlation between a Memory Channel and its associated Memory Devices. Each device presents one or more loads to the channel; the sum of all device loads cannot exceed the channel’s defined maximum.

Note: This structure type was added for specification v2.3.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>37</td>
    <td>Management Device Threshold Data structure indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td></td>
    <td>Length of the structure, computed by the BIOS as 7 + 3 * (Memory Device Count).<br>Note: This field must not be used to determine the number of memory devices specified within the structure, to allow future structure growth by appending information after the Load/Handle list.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Channel Type</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the type of memory associated with the channel, see 3.3.38.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Maximum Channel Load</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The maximum load supported by the channel; the sum of all device loads cannot exceed this value.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>Memory Device Count (n)</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the number of Memory Devices (Type 11h) that are associated with this channel. This value also defines the number of Load/Handle pairs that follow.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Memory Device Load</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The channel load provided by the 1st Memory Device associated with this channel.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Memory Device1 Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The structure handle that identifies the 1st Memory Device associated with this channel.</td>
  </tr>
  <tr>
    <td>7 + 3*(n-1)</td>
    <td>Memory Device<sub>n</sub> Load</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The channel load provided by the nth Memory Device associated with this channel.</td>
  </tr>
  <tr>
    <td>8 + 3*(n-1)</td>
    <td>Memory Device<sub>n</sub> Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The structure handle that identifies the nth Memory Device associated with this channel.</td>
  </tr>
</table>

3.3.38.1 Memory Channel — Channel Type

Important Note: Enumerated values are controlled by the DMTF, not this specification.

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>01h</td>
    <td>Other</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>RamBus</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>SyncLink</td>
  </tr>
</table>
3.3.39 IPMI Device Information (Type 38)

The information in this structure defines the attributes of an Intelligent Platform Management Interface (IPMI) Baseboard Management Controller (BMC). Refer to the documents available at http://developer.intel.com/design/servers/ipmi/spec.htm for full documentation of IPMI.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>38</td>
    <td>IPMI Device Information structure indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, a minimum of 10h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td></td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Interface Type</td>
    <td>BYTE</td>
    <td>ENUM</td>
    <td>Baseboard Management Controller (BMC) interface type, see 3.3.39.1.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>IPMI Specification Revision</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the IPMI Specification Revision, in BCD format, to which the BMC was designed. Bits 7:4 hold the most significant digit of the revision, while bits 3:0 hold the least significant bits, e.g. a value of 10h indicates revision 1.0.</td>
  </tr>
  <tr>
    <td>06h</td>
    <td>I²C Slave Address</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>The slave address on the I²C bus of this BMC.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>NV Storage Device Address</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Bus id of the NV storage device. If no storage device exists for this BMC, the field is set to 0FFh.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Base Address</td>
    <td>QWORD</td>
    <td>Varies</td>
    <td>Identifies the base address (either memory-mapped or I/O) of the BMC. If the least-significant bit of the field is a 1, the address is in I/O space; otherwise, the address is memory-mapped. Refer to the IPMI Interface Specification for usage details.</td>
  </tr>
</table>

3.3.39.1 IPMI Device Information — BMC Interface Type

<table>
  <tr>
    <th>Byte Value</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Unknown</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>KCS: Keyboard Controller Style</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>SMIC: Server Management Interface Chip</td>
  </tr>
  <tr>
    <td>03h</td>
    <td>BT: Block Transfer</td>
  </tr>
  <tr>
    <td>04h to 0FFh</td>
    <td>Reserved for future assignment by this specification</td>
  </tr>
</table>

3.3.40 System Power Supply (Type 39)

This structure identifies attributes of a system power supply. One instance of this record is present for each possible power supply in a system.

Note: This structure was added for specification v2.3.1.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>39</td>
    <td>Power Supply Record indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure, a minimum of 10h.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the power supply structure.</td>
  </tr>
  <tr>
    <td>04h</td>
    <td>Power Unit Group</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Identifies the power unit group to which this power supply is associated. Specifying the same Power Unit Group value for more than one System Power Supply structure indicates a redundant power supply configuration. The field’s value is 00h if the power supply is not a member of a redundant power unit, non-zero values imply redundancy and that at least one other power supply will be enumerated with the same value.</td>
  </tr>
  <tr>
    <td>05h</td>
    <td>Location</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that identifies the location of the power supply, e.g. “in the back, on the left-hand side” or “Left Supply Bay.”</td>
  </tr>
</table>
<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>06h</td>
    <td>Device Name</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that names the power supply device, e.g. “DR-36”.</td>
  </tr>
  <tr>
    <td>07h</td>
    <td>Manufacturer</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that names the company that manufactured the supply.</td>
  </tr>
  <tr>
    <td>08h</td>
    <td>Serial Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains the serial number for the power supply.</td>
  </tr>
  <tr>
    <td>09h</td>
    <td>Asset Tag Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains the Asset Tag Number.</td>
  </tr>
  <tr>
    <td>0Ah</td>
    <td>Model Part Number</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>The number of the string that contains the OEM Part Order Number.</td>
  </tr>
  <tr>
    <td>0Bh</td>
    <td>Revision Level</td>
    <td>BYTE</td>
    <td>STRING</td>
    <td>Power supply Revision String, e.g. “2.30”</td>
  </tr>
  <tr>
    <td>0Ch</td>
    <td>Max Power Capacity</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>Maximum sustained power output in Watts. Set to 0x8000 if unknown. Note that the units specified by the DMTF for this field are milliWatts.</td>
  </tr>
  <tr>
    <td>0Eh</td>
    <td>Power Supply Characteristics</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>See 3.3.40.1.</td>
  </tr>
  <tr>
    <td>10h</td>
    <td>Input Voltage Probe Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, of a Voltage Probe (Type 26) monitoring this power supply’s input voltage. A value of 0xFFFF indicates that no probe is provided.</td>
  </tr>
  <tr>
    <td>12h</td>
    <td>Cooling Device Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, of a Cooling Device (Type 27) associated with this power supply. A value of 0xFFFF indicates that no cooling device is provided.</td>
  </tr>
  <tr>
    <td>14h</td>
    <td>Input Current Probe Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, of the Electrical Current Probe (Type 29) monitoring this power supply’s input current. A value of 0xFFFF indicates that no current probe is provided.</td>
  </tr>
</table>

3.3.40.1 Power Supply Characteristics

Important Note: Refer to 3.3 for the CIM and DMI attributes associated with these enumerated values.

<table>
  <tr>
    <th>Bit Range</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>15 to 14</td>
    <td>Reserved, set to 00b</td>
  </tr>
  <tr>
    <td>13 to 10</td>
    <td>DMTF Power Supply Type<br>0001b Other<br>0010b Unknown<br>0011b Linear<br>0100b Switching<br>0101b Battery<br>0110b UPS<br>0111b Converter<br>1000b Regulator<br>1001b to 1111b — Reserved for future assignment</td>
  </tr>
  <tr>
    <td>9 to 7</td>
    <td>Status<br>001b Other<br>010b Unknown<br>011b OK<br>100b Non-critical<br>101b Critical, power supply has failed and has been taken off-line</td>
  </tr>
  <tr>
    <td>6 to 3</td>
    <td>DMTF Input Voltage Range Switching<br>0001b Other<br>0010b Unknown<br>0011b Manual<br>0100b Auto-switch<br>0101b Wide range<br>0110b Not applicable<br>0111b to 1111b — Reserved for future assignment</td>
  </tr>
  <tr>
    <td>2</td>
    <td>Power supply is unplugged from the wall, if 1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>Power supply is present, if 1</td>
  </tr>
</table>
3.3.41 Inactive (Type 126)

This structure definition supports a system implementation where the SMBIOS structure-table is a superset of all supported system attributes and provides a standard mechanism for the system BIOS to signal that a structure is currently inactive and should not be interpreted by the upper-level software.

For example, a portable system might include System Slot structures that are reported only when the portable has docked. An undocked system would report those structures as Inactive. When the system was docked, the structure Type would be changed from Inactive to the System Slot equivalent by the system-specific software.

Upper-level software that interprets the SMBIOS structure-table should bypass an Inactive structure just like a structure type that the software does not recognize.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>126</td>
    <td>Inactive structure indicator</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
</table>

3.3.42 End-of-Table (Type 127)

This structure type identifies the end of the structure table that might be earlier than the last byte within the buffer specified by the structure. To ensure backward compatibility with management software written to previous versions of this specification, a system implementation should use the end-of-table indicator in a manner similar to the Inactive (Type 126) structure type — the structure table is still reported as a fixed-length and the entire length of the table is still indexable. If the end-of-table indicator is used in the last physical structure in a table, the field’s length is encoded as 4.

Note: This structure type was added for specification v2.2.

<table>
  <tr>
    <th>Offset</th>
    <th>Name</th>
    <th>Length</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>00h</td>
    <td>Type</td>
    <td>BYTE</td>
    <td>127</td>
    <td>End-of-table indicator.</td>
  </tr>
  <tr>
    <td>01h</td>
    <td>Length</td>
    <td>BYTE</td>
    <td>Varies</td>
    <td>Length of the structure.</td>
  </tr>
  <tr>
    <td>02h</td>
    <td>Handle</td>
    <td>WORD</td>
    <td>Varies</td>
    <td>The handle, or instance number, associated with the structure.</td>
  </tr>
</table>
Appendices

4. Conformance Guidelines

The following describes the conformance requirements for an SMBIOS v2.4 or later implementation.

1. The table anchor string "_SM_" is present in the address range 0xF0000 to 0xFFFFF on a 16-byte boundary.
2. Table entry-point verification:
   2.1. The Entry Point Length field value is at least 0x1F.
   2.2. The entry-point checksum evaluates to 0.
   2.3. The SMBIOS Version (Major.Minor) is at least 2.4.
   2.4. The Intermediate Anchor String is "_DMI."
   2.5. The intermediate checksum evaluates to 0.
3. The structure-table is traversable and conforms to the entry-point specifications:
   3.1. The structure-table's linked-list is traversable within the length and structure-count bounds specified by the entry-point structure.
   3.2. The overall size of the structure table is less than or equal to the Structure Table Length specified by the entry-point structure.
   3.3. Each structure's length must be at least 4 (the size of a structure header).
   3.4. No structure handle number is repeated.
   3.5. The last structure is the end-of-table (0x7F).
   3.6. The number of structures found within the table equals the Number of SMBIOS Structures field present in the entry-point.
   3.7. The maximum structure size (formatted area plus its string-pool) is less than or equal to the Maximum Structure Size specified by the entry-point.
4. Required structures and corresponding data are present, see 3.2 Required Structures and Data on page 31:
   4.1. BIOS Information (Type 0)
       4.1.1. One and only one structure of this type is present.
       4.1.2. The structure Length field is at least 18h.
       4.1.3. BIOS Version string is present and non-null
       4.1.4. BIOS Release Date string is present, non-null, and includes a 4-digit year.
       4.1.5. BIOS Characteristics: bits 3:0 are all 0, at least one of bits 31:4 is set to 1.
   4.2. System Information (Type 1)
       4.2.1. One and only one structure of this type is present.
       4.2.2. The structure Length field is at least 1Bh.
       4.2.3. Manufacturer string is present and non-null
       4.2.4. Product Name string is present and non-null
       4.2.5. UUID field is neither 00000000 00000000 nor FFFFFFFF FFFFFFFF.
       4.2.6. Wake-up Type field is neither 00h (Reserved) nor 02h (Unknown).
   4.3. System Enclosure (Type 3)
       4.3.1. One or more structure of this type is present.
4.3.2. The structure length is at least 0Dh.
4.3.3. Manufacturer string is present and non-null in each structure.
4.3.4. Type field is neither 00h (Reserved) nor 02h (Unknown)

4.4. Processor Information (Type 4)
4.4.1. The number of structures defines the maximum number of processors supported by the system; at least one structure with a Processor Type field of "Central Processor" must be present.
4.4.2. Each structure's length is at least 20h.
4.4.3. Socket Designation string is present and non-null
4.4.4. Processor Type field is neither 00h (Reserved) nor 02h (Unknown)
4.4.5. (*)Processor Family field is neither 00h (Reserved) nor 02h (Unknown)
4.4.6. (*)Processor Manufacturer string is present and non-null
4.4.7. Max Speed field is non-0.
4.4.8. (*)CPU Status sub-field of the Status field is not 0 (Unknown)
4.4.9. Processor Upgrade field is neither 00h (Reserved) nor 02h (Unknown)
4.4.10. Lx (x=1,2,3) Cache Handle fields, if not set to 0xFFFF, reference Cache Information (Type 7) structures.

Note: Fields preceded by (*) are only checked if the CPU Socket Populated sub-field of the Status field is set to "CPU Populated".

4.5. Cache Information (Type 7)
4.5.1. One structure is present for each external-to-the-processor cache.
4.5.2. Each structure's Length is at least 13h.
4.5.3. Socket Designation string is present and non-null if the cache is external to the processor (Location sub-field of Cache Configuration field is 01b).
4.5.4. Operational Mode and Location sub-fields of the Cache Configuration field are not 11b (Unknown)

4.6. System Slots (Type 9)
4.6.1. One structure is present for each upgradeable system slot.
4.6.2. Each structure's Length is at least 0Dh.
4.6.3. Slot Designation string is present and non-null.
4.6.4. Slot Type is neither 00h (Reserved) nor 02h (Unknown).
4.6.5. Slot Data Bus Width is neither 00h (Reserved) or 02h (Unknown)
4.6.6. Current Usage is not set to 00h (Reserved). If the "Slot Type" provides device presence-detect capabilities, e.g. PCI or AGP, Current Usage is not set to 02h (Unknown).
4.6.7. Slot ID is set to a meaningful value.
4.6.8. Slot Characteristics 1, bit 0, is not set to 1.

4.7. Physical Memory Array (Type 16)
4.7.1. At least one structure is present with "Use" set to 03h (System memory)
4.7.2. Each structure's length is at least 0Fh.
4.7.3. Location is neither 00h (Reserved) nor 02h (Unknown)
4.7.4. Use is neither 00h (Reserved) nor 02h (Unknown).
4.7.5. Memory Error Correction is neither 00h (Reserved) nor 02h (Unknown)
4.7.6. Maximum Capacity is not set to 80000000h (Unknown)
4.7.7. Number of Memory Devices is not 0 and equals the number of Memory Device (Type 17) structures that reference the handle of the Physical Memory Array structure.

4.8. Memory Device (Type 17)
4.8.1. For each Physical Memory Array, there must be "Number of Memory Devices" Memory Device structures that map back (via Handle) to the referencing memory array. One structure is required for each socketed system-memory device, whether or not the socket is currently populated. If the system includes soldered-on system-memory, one additional structure is required to identify that memory device.
4.8.2. Each structure's length is at least 15h.
4.8.3. Memory Array Handle references a Physical Memory Array (Type 16) structure.
4.8.4. Total Width is not 0FFFFh (Unknown) if the memory device is installed (Size is not 0).
4.8.5. Data Width is not 0FFFFh (Unknown)
4.8.6. Size is not 0FFFFh (Unknown)
4.8.7. Form Factor is not 00h (Reserved) or 02h (Unknown)
4.8.8. Device Set is not 0FFh (Unknown)
4.8.9. Device Locator string is present and non-null.

4.9. Memory Array Mapped Address (Type 19)
4.9.1. One structure is provided for each contiguous block of memory addresses mapped to a Physical Memory Array.
4.9.2. Each structure's length is at least 0Fh.
4.9.3. Ending Address value is higher in magnitude than the Starting Address value.
4.9.4. Memory Array Handle references a Physical Memory Array (Type 16)
4.9.5. Each structure's address range (Starting Address to Ending Address) is unique and non-overlapping.
4.9.6. Partition Width is not 0.

4.10. Memory Device Mapped Address (Type 20)
4.10.1. Sufficient structures are provided to provide device-level mapping to all address space defined by the Memory Array Mapped Address (Type 19) structures.
4.10.2. Each structure's length is at least 13h.
4.10.3. Ending Address value is higher in magnitude than the Starting Address value.
4.10.4. Memory Device Handle references a Memory Device (Type 17) structure.
4.10.5. Memory Array Mapped Address Handle references a Memory Array Mapped Address (Type 19) structure.
4.10.6. Partition Row Position value is not 0 (Reserved), 0FFh (Unknown), or greater than the Partition Width field of the referenced Memory Array Mapped Address structure.
4.10.7. Interleave Position is not 0FFh (Unknown)
4.10.8. Interleaved Data Depth is not 0FFh (Unknown)

4.11. Boot Integrity Services (BIS) Entry Point (Type 31). This structure is optional, but if it is present the following checks are performed:
4.11.1. The structure's length is at least 1Ch.
4.11.2. The structure-level checksum evaluates to 00h.
4.11.3. 16-bit Entry Point is not 0.
4.11.4. 32-bit Entry Point is not 0.

4.12. System Boot Information (Type 32)

    4.12.1. One and only one structure of this type is present.

    4.12.2. The structure's length is at least 0Bh.

5. Using the Table Convention

This section contains pseudo-code that describes the method that application software can use to parse the table-based SMBIOS structures. The example searches for the first structure of the type specified, returning the handle of the structure found or 0xFFFF if no structure of the type was found in the list. TableAddress and StructureCount values are those previously found by locating the Table Entry Point structure in low memory.

typedef unsigned short ushort;
typedef unsigned char uchar;
typedef struct
{
    uchar Type;
    uchar Length;
    ushort Handle;
} HEADER;

ushort FindStructure( char *TableAddress, ushort StructureCount, uchar Type )
{
    ushort i, handle;
    uchar lasttype;

    i = 0;
    handle = 0xFFFF;

    while( i < StructureCount && handle == 0xFFFF )
    {
        i++;
        lasttype = ((HEADER *)TableAddress)->Type;
        if( lasttype == Type )
        {
            handle = ((HEADER *)TableAddress)->Handle;
        } /* Found first structure of the requested type */
        else
        {
            TableAddress += ((HEADER *)TableAddress)->Length;
            while( *((int *)TableAddress) != 0 )
            {
                TableAddress++;
            } /* Get past trailing string-list */
            TableAddress += 2;
        } /* Increment address to start of next structure */
    } /* END while-loop looking for structure type */

    return handle;
} /* END FindStructure */